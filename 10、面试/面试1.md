### 一、nextjs
## 1、定位： 
Next.js 是一个基于 React 的全栈框架，提供开箱即用的解决方案，用于构建生产级应用（SSR、SSG、ISR、API Routes、路由、优化等）。

## 2、关键特性：
# （1）App Router (核心变革)： 
Next.js 13 引入的全新路由架构（基于 /app 目录），取代了之前的 Pages Router (/pages)。它是理解 RSC 和现代 Next.js 开发的基础。

# （2）React 服务器组件 (RSC - 革命性特性)：
核心理念： 
组件默认在服务器端渲染。允许直接在组件内部进行服务器端操作（访问文件系统、数据库、安全访问环境变量/密钥、无成本的异步数据获取）。

优势：
1. 更小的客户端包体积： 服务器组件代码不会发送到客户端，减少 JS 下载量，提升初始加载性能。
2. 更快的初始加载： 服务器直接生成 HTML，用户更快看到内容。
3. 改进的 SEO： 搜索引擎更容易抓取服务器渲染的内容。
4. 直接访问后端资源： 简化数据获取逻辑（无需 API 层）。
5. 自动代码分割： 基于路由和 import() 动态导入。
6. 使用： 在 App Router 中，默认所有组件都是 RSC。使用 'use client' 指令将组件标记为客户端组件。
7. 与客户端组件交互： 通过 props 传递数据或 JSX。注意序列化限制（不能传递函数、类实例等）。

# （3）服务器端渲染 (SSR)：

在 Next.js 中的实现： App Router 中，RSC 本身就是 SSR 的一种形式（流式传输）。传统的 getServerSideProps 在 Pages Router 中使用，在 App Router 中可以通过在 Server Component 中直接获取数据替代。

优势： 每次请求时在服务器渲染页面，提供动态、个性化的内容和最新的 SEO。

适用场景： 数据高度个性化（用户仪表盘）、频繁变化（新闻源）、需要访问请求上下文（cookies, headers）的页面。

# （4）静态站点生成 (SSG)：

在 Next.js 中的实现： Pages Router 使用 getStaticProps/getStaticPaths。App Router 中使用 generateStaticParams 结合在构建时获取数据的 Server Components。
优势： 在构建时生成静态 HTML 文件，提供极致的加载速度和性能，易于 CDN 缓存。

适用场景： 内容不经常变化的页面（博客、文档、营销页、产品列表）。

# （5）增量静态再生 (ISR)：

核心理念： 结合 SSG 和 SSR 的优势。首先生成静态页面，然后在指定的时间间隔 (revalidate) 或按需（通过 revalidatePath/revalidateTag）在后台重新验证并重新生成过期的页面。

优势： 保持 SSG 的速度，同时允许内容按需或在后台更新，无需重新构建整个站点。

在 Next.js 中的实现： Pages Router 在 getStaticProps 中设置 revalidate 选项。App Router 在 fetch 请求中使用 next: { revalidate: 60 } 选项或在路由处理程序中设置。

# （5）服务器操作 (Server Actions - Next.js 14 稳定)：

核心理念： 
允许直接从 React 组件（通常是客户端组件）调用在服务器端执行的异步函数。用于数据变更（表单提交、数据库更新）。

优势：
1. 简化数据变更： 无需手动创建 API 路由，直接在组件中写服务器逻辑（在标记为 'use server' 的函数或文件中）。
2. 安全性： 敏感逻辑和凭据保留在服务器端。
3. 渐进增强： 即使 JavaScript 未加载，基于 <form> 的操作也能工作。
4. 使用： 在组件中使用 action={serverActionFunction} (表单) 或 onClick={() => serverActionFunction()} (按钮等)。函数需标记 'use server' 或定义在单独的文件中。

面试要点：

清晰区分 App Router vs Pages Router。

深刻理解 RSC 的原理、优势和限制（特别是与客户端组件的边界和交互）。

掌握 SSR、SSG、ISR 的区别、优缺点和适用场景。

理解 流式渲染 如何提升用户体验。

了解 Server Actions 的作用和基本用法。

能解释 Next.js 如何优化性能（图片、字体、脚本优化等）。



### 总结
## 1、SSR和RSC
1、以deepseek为例，页面简单，但是每次给出的答案都需要调用服务，需要庞大的数据，并且是只更新问答框这一个组件，不是整个页面，所以React Server Components(RSC)非常适合。而且数据层面也更加安全。传统 SSR通常在页面级入口点 (如 getServerSideProps, getStaticProps) 进行数据获取。数据作为 props 传递给页面组件。组件内部通常无法直接进行服务器端数据获取。这种方式适合页面初始化提升一下性能。

getStaticProps是构建时或结合getStaticPaths按需重新生成，适合数据不频繁变化的页面（如博客、产品列表、文档站）；而getServerSideProps是每次调用服务都会执行一次，适合需要实时数据或个性化内容的页面（如订单页）。

在 Next.js 中，组件默认是 RSC（但有条件）。App Router 专属：只有在 Next.js 13/14+ 中使用 App Router (/app 目录) 时，组件才默认具备 RSC 能力。除非使用标记 'use client' 标记不

## 2、App Router vs Pages Router
## 3、Next.js 如何优化性能（图片、字体、脚本优化等）
见nextjs.md


### 二、redux、zustand和jotai
核心问题： 在 React 应用中，如何跨组件（尤其是非父子关系的组件）高效、可预测地共享和管理状态？
## 1、Redux (经典/主流)：
核心理念：

单一数据源 (Store)： 整个应用的状态存储在一个 JavaScript 对象树中。

状态是只读的： 唯一改变状态的方法是触发一个 Action（描述发生了什么事件的普通对象）。

使用纯函数 (Reducer) 执行修改： 编写 Reducer 函数接收当前 State 和 Action，返回新的 State（不可变更新）。

关键概念： Store, Action, Reducer, Dispatch, Selector.

现代工具 (Redux Toolkit - RTK)： 强烈推荐使用！ 极大简化 Redux 开发（configureStore, createSlice, createAsyncThunk, createEntityAdapter, RTK Query）。

优势： 严格的架构、强大的中间件支持（如 Redux Thunk, Saga）、优秀的 DevTools、庞大的生态系统和社区。适合大型复杂应用，需要强一致性和可追溯性的场景。

劣势： 相对样板代码较多（即使使用 RTK），概念学习曲线稍陡。

Zustand (轻量/灵活)：

核心理念： 基于 Hook 的极简状态管理。创建一个 Store（包含状态和更新状态的方法）。组件使用 Hook (useStore) 订阅 Store 或其部分状态。

特点：

无样板： API 极其简洁。

不可变性： 更新状态时返回新对象（或使用 Immer 简化）。

细粒度订阅： 组件只订阅其实际使用的状态片段，避免不必要的渲染。

脱离 Context： 不依赖 React Context，避免 Provider 嵌套问题。

优势： 学习曲线平缓，代码简洁，性能优异（细粒度订阅），非常灵活。适合中小型应用或作为大型应用中局部状态管理方案。

劣势： 生态系统和中间件不如 Redux 丰富（但够用），架构约束较少，大型项目需自行组织。

Jotai (原子化/Reactish)：

核心理念： 受 Recoil 启发，采用 原子 (Atom) 的概念。原子是最小的状态单位。通过组合原子（atom）和派生原子（derived atom）构建状态图。使用 Hook (useAtom) 读取和写入原子状态。

特点：

真正的 React 风格： 完全拥抱 React Hooks 和 Suspense。

原子化： 状态被分解成细粒度的原子，组件只订阅它们依赖的原子。

派生状态： 轻松创建基于其他原子的计算值。

无全局 Store： 状态通过原子定义和组合隐式存在。

极简 API： 核心 API (atom, useAtom) 非常小。

优势： 与 React 心智模型高度契合，自动优化渲染（依赖跟踪），非常适合管理细粒度、派生状态多的场景。学习曲线低（如果熟悉 React Hooks）。

劣势： 相对较新，生态系统和工具链还在发展中。调试可能不如 Redux 直观。



