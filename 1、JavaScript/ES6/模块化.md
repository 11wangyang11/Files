# 1、概念
CommonJS和ESModules是一种模块化方案。模块化方案是一种用于组织、封装和复用代码的方法论或规范。它定义了如何将代码划分为独立的模块，并规定了模块之间的依赖关系、导入和导出机制等。模块化方案的目的是解决代码的可维护性、可读性和复用性等问题。通过模块化，开发者可以将代码分割成独立的功能模块，每个模块只关注自己的功能，并通过明确的接口与其他模块进行交互。这样可以降低代码的复杂度，提高代码的可维护性和可读性，并促进代码的复用和模块化开发。   

JavaScript代码通常是运行在各个浏览器以及node环境中。由于语言本身在早期并没有原生的模块化支持，开发者使用了各种模块化方案来实现模块化。其中一些常见的模块化方案包括 CommonJS、AMD、CMD、UMD 等。  

# 2、模块化方案
常用模块化方案有 CommonJS、ESModules、AMD、CMD、UMD 等。  

## 1、简要介绍
- CommonJS 是一种在服务器端 JavaScript 环境中实现模块化的规范，它使用`require`和`module.exports`来导入和导出模块，`require`是 **同步加载** ，导入模块会阻塞后续代码的执行。CommonJS 最初是由 Ryan Dahl 在开发 Node.js 时提出的，旨在解决服务器端 JavaScript 的模块化问题。  

- ESModules，是ES6推出的原生模块化方案，现在新版浏览器多数都支持 ESModules 了。

- AMD（*Asynchronous Module Definition*）是一种在浏览器端实现 **异步模块加载** 的规范，它使用`define`和`require`来定义和引入模块。AMD 最初是由 RequireJS 提出的，旨在解决浏览器端 JavaScript 的模块化问题。 

- CMD (*Common Module Definition*) 也是一种在浏览器端实现 **异步模块加载** 的规范，与CMD类似，也是使用`define`和`require`来定义和引入模块。与AMD最大的区别是，CMD推崇在*使用时*加载模块，而AMD是推崇*依赖前置*。

- UMD（*Universal Module Definition*）是一种通用的模块化方案，它可以在不同的环境中运行，包括浏览器和 Node.js。UMD 兼容 CommonJS 和 AMD 的模块化规范，使得模块可以在不同的环境中使用。   

## 2、CommonJS模块

在 ES6 之前，JavaScript 并没有原生的模块化支持，ES6 之前的JavaScript代码一般可遵循 CommonJS 规范，然后需要使用工具(如 *webpack* 等)将 CommonJS 模块化代码转为可识别的代码。ES6 提出了新的模块化方案 ESModules (所以是 JavaScript 原生模块化方案)，并随着时间的推移，较新的浏览器开始慢慢支持 ESModules。要是早期的JavaScript就提供了一个模块化方案，就不用像现在这样，即便使用了 ES6 的 ESModules，还要考虑把它转为 CommonJS 代码，来兼容一些低版本浏览器。。。   

下面简单说一下commonJS的几个规范：  

**（1）导出**  

1. `modules.export = {};`
2. `exports.xxx = '../..';`

注意，没有 *exports = { name: 'xxx' }* 这种写法，可能export.name中像是exports对象的name属性，所以感觉 *exports = { name: 'xxx'}* 这种写法是正确的。这只是一种规范。。。。

**（2）导入**  

CommonJS 使用 `require()` 导入模块。注意，`require()` 是 *nodeJS* 的全局方法，不止 CommonJS 使用 `require()` 作为模块导入，AMD(RequireJS)、SystemJS也使用`require()`。因为 CommonJS 最初就是为了在 *NodeJS* 环境中使用而设计的，所以 CommonJS 规范代码是可以直接运行在nodeJS环境下的，但是在 windows 下是不能用的。浏览器环境并不支持 CommonJS 规范，所以需要使用构建工具(如 webpack 等)将 CommonJS 规范代码转为浏览器可识别代码。  

**（3）模块标识符**  

模块标识符就是 require 模块的方式，一共有3种：  

- 相对路径： `require('./')`、 `require('../')`；
- 绝对路径： `require('/')`;
- 模块名： 不使用路径，使用内置模块、第三方模块或者自定义模块，如 `require('path')`、`require('lodash')` 等。其中，自定义模块会从当前目录的node_modules中查找，如果没有就会向上一级继续查找node_modules，直到根目录下没有就抛出异常。  

*由于模块标识符可能没有后缀，CommonJS会按照下面规则定位模块：*  

1. 首先，会尝试按照指定的模块名直接查找对应的文件或目录。
2. 如果找不到与模块名完全匹配的文件或目录，会尝试按照以下顺序查找文件：
   - 按照模块名查找同名的 `.js` 文件。
   - 按照模块名查找同名的 `.json` 文件。
   - 按照模块名查找同名的目录，并在该目录中查找 `package.json` 文件。
     - 如果找到 `package.json` 文件，并且该文件中有 `main` 字段指定了入口文件，则使用指定的入口文件。
     - 如果找到 `package.json` 文件，但没有 `main` 字段，则默认使用该目录下的 `index.js` 文件作为入口文件。
   - 如果以上步骤都没有找到对应的文件或目录，则抛出一个错误。   

**（4）CommonJS规范特点**   

- 所有代码都运行在模块作用域，不会污染全局作用域；
- 模块是同步加载的，即只有加载完成，才能执行后面的操作；
- 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存；
- CommonJS输出是值的拷贝(即，`require`返回的值是被输出的值的浅拷贝，模块内部的变化也不会影响这个值，不过引用类型的修改会影响输出值)。

1. 同步加载，指的是代码中使用 `require('xx')` 导入模块的话，会先把`xx模块`的所以内容全部执行完毕（包括非导出部分），然后将导出的内容返回给导入模块。但是，我们不能简单理解为把被导入模块的代码直接放进当前模块。因为模块是运行在模块作用域内的，导入模块和被导入模块是相互独立的模块，代码、变量等都是相互隔离的。  

m1.js   

```js
console.log('m1模块')
module.exports = {
    name: 'Tonny',
    sex: 'boy'
}
```

m2.js  

```js
require('./m1');
console.log('m2模块')
```

结果就是：  

```js
m1模块
m2模块
```
2. 模块加载后会缓存，导致同一个模块多次调用时的结果一样。比如：   

m1.js  

```js
var name = 'Tonny';
var sex = 'boy';

exports.name = name;
exports.sex = sex;
``` 

m2.js  

```js
var m1 = require('./m1');
m1.sex = 'girl';
console.log(m1);

var m2 = require('./m1');
console.log(m2);
```
输出结果为：  

```js
{ name: 'Tonny', sex: 'girl' }
{ name: 'Tonny', sex: 'girl' }
```
首先，commonJS 输出的是值的拷贝，所以并不是 `m1.sex` 修改了 `m1模块`的值；其次，`m1模块`和 `m2模块`是相互独立的，不存在可以相互修改的问题。这就是因为缓存导致的。正式因为 CommonJS 的同步加载、缓存机制，导致有些人往往喜欢将其理解为被导入模块就是把代码直接放在了当前模块内了。

## 3、AMD规范和CMD规范

CommonJS 是为服务端 NodeJS 推出的，是同步加载。浏览器使用同步加载的话会很慢。所以会有 AMD 和 CMD ，它们采用异步的方式加载模块。它们是使用`define`的方式导出模块,定义如下:  

```js
define(id?, dependencies?, factory)
```

*AMD 和 CMD 最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同，二者皆为异步加载模块。* 所谓处理时机指的是：   

- AMD 推崇依赖前置，如果在`define`的`dependencies`参数中就定义好了依赖，js 很方便的就知道要加载的是哪个模块了，会立即加载它。
- CMD 推崇就近依赖，通常在用到的时候再去`require`，而不是在`dependencies`中定义好依赖。

示例：    

同样在`match.js`中加载`m1模块`。   

AMD 写法如下：   

**math.js**  

```js
define(['m1'], function (m1) {
  console.log('我是math')
  var add = function (a, b) {
    return a + b;
  }
  var print = function () {
    console.log(m1.name)
  }
  return {
    add: add,
    print: print
  }
})
```
CMD 写法如下：  

**math.js**   

```js
define(function (require, exports, module) {
  console.log('我是math')
  var m1 = require('m1');
  var add = function (a, b) {
    return a + b;
  }
  var print = function () {
    console.log(m1.name)
  }
  module.exports = {
    add: add,
    print: print
  }
})
```

假如此时m1.js中有一个语句是在m1模块被加载的时候打印出`我是m1`。那么AMD会先加载`我是m1`，而CMD会先执行`我是math`。

## 4、ESModules

。。。。，详细分类并介绍一下。。。
## （1）编译/加载
在 ES 模块中，编译时进行静态分析可以提前知道模块的导出内容，即哪些变量、函数或类将被导出。这样做的好处是可以优化代码的加载和执行过程，具体体现在以下几个方面：  

1. 懒加载：静态分析可以确定模块的导入和导出关系，从而可以在代码加载阶段就知道哪些模块需要被加载。这使得可以采用懒加载（Lazy Loading）的方式，只在需要时才加载相应的模块，而不是一次性加载所有模块。这样可以减少不必要的网络请求和资源消耗，提高页面的加载速度和性能。  
  
2. 依赖分析：静态分析可以提前知道模块的依赖关系，即哪些模块依赖于其他模块。这使得可以进行依赖分析，确定模块之间的依赖关系，并进行优化。例如，可以将具有共同依赖的模块打包成一个单独的文件，减少重复的代码和资源加载，提高代码的复用性和执行效率。  
  
3. 代码压缩和优化：静态分析可以提前知道模块的导出内容，从而可以进行代码的压缩和优化。例如，可以删除未被使用的导出内容，减少代码的体积和加载时间。还可以进行代码的优化，例如函数内联、常量折叠等，提高代码的执行效率和性能。  
  
通过编译时进行静态分析，可以在代码执行之前就获得关于模块的重要信息，从而进行代码加载和执行的优化。这种优化可以减少不必要的资源消耗，提高代码的加载速度和执行效率，从而提升应用程序的性能和用户体验。  

## （2）ESModules默认导出

上面提到依赖分析等，涉及到模块导出问题。为什么ES模块本身为什么不包含默认导出内容？。。。。

## （3）打包
在使用 ES 模块时，虽然可以进行动态加载，但在打包时，不管commonJS还是es模块，所有导入的模块文件通常会被打包进最终的输出文件中。所以优化包的大小，就必须比如：

```js
// 分包
module.exports = is_X ? require('./module.xModule') : require('./module.yModule');

// XApp独有模块
const XModules = {
    get TapView() {
        const module = require('./tapView');
        return module && module.__esModule ? module.default : module;
    },
    get BookView() {
        const module = require('./bookView');
        return module && module.__esModule ? module.default : module;
    }
}
// y独有模块
// ...
```

# 2、ES模块与commonJS比较
## 1、lib / es / dist，三种产物
（1）dist 是webpack/metro的产物；es和lib是react或者react native项目中两个常见的文件夹，它们通常用于存放JavaScript代码。 

（2）"es"文件夹中存放的是经过Babel转译后的ES模块（ES modules）代码。ES模块是一种用于在JavaScript中导入和导出代码的标准化语法。这些代码通常用于开发环境，因为它们可以利用最新的JavaScript语言特性和语法。  
  
（3）"lib"文件夹中存放的是经过Babel转译后的CommonJS模块（CommonJS modules）代码。CommonJS模块是一种用于在Node.js环境中导入和导出代码的规范。这些代码通常用于生产环境，因为它们具有更广泛的兼容性，可以在各种JavaScript运行环境中使用。  
  
通常，在React Native项目中，开发者可以选择使用"es"文件夹中的代码进行开发和调试，而将"lib"文件夹中的代码用于构建和发布应用程序。这样可以在开发过程中享受到更好的开发体验，同时在生产环境中获得更好的兼容性。

## 2、引入es还是lib？
import是引入es，require是引入lib。我们引入一个npm包，如果使用vscode点击会发现跳转到了lib文件下，是因为vscode默认是node环境，链接时按照require来链接；但最终打包webpack是依据你当前导入语句来决定的，import走的就是es，require才走的是lib。目前，开发基本都是使用es6，即使用import的方式导入模块，但是会使用babel进行向下兼容。


。。。

3、Babel
注意，Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如`Iterator`、`Generator`、`Set`、`Map`、`Proxy`、`Reflect`、`Symbol`、`Promise`等全局对象，以及一些定义在全局对象上的方法（比如`Object.assign`）都不会转码。

举例来说，ES6 在`Array`对象上新增了`Array.from`方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用`babel-polyfill`，为当前环境提供一个垫片。否则比如代码`colors = Array.from(str.matchAll(regex), match => match[1]);`，在commonJS环境下会报错。(polyfill配置方式见[bable配置polyfill](https://www.babeljs.cn/docs/babel-preset-env))。但是，polyfill会增加额外的空间和性能开销！

**npm**

1、npm list / npm list -g查看npm安装的依赖和工具

2、npx babel src —out-dir dist编译文件，依赖babel设置

3、tsc指令，会将ts转为js，也会生成dist文件(因为相关配置在tsconfig.ts中)，但是这并不是babel后的代码。想看babel后的commonJS代码，需要运行babel。

4、npx babel src —out-dir dist这里src需要是js文件。不知道为什么ts文件npx babel src/example.ts —out-dir dist为空，但是npx babel src/example.ts却可以！

5、Babel 的 `modules` 选项只会影响到源代码中的模块导入和导出语法的转换，而不会影响内置对象或全局函数的转换。所以，babel并不会直接将Array.from等es6的新方法改成es5写法，而是运行时转，所以需要配置babel，一方面支持polyfills，另一方面配置@babel/plugin-transform-runtime插件。

但是目前测试下来还是没有效果。。。。不知道怎么弄。。。


资料：

1、[webpack打包commonJS和esmodule区别](https://juejin.cn/post/7093428816785670152)

2、[Webpack打包commonjs和esmodule混用模块的产物对比](https://juejin.cn/post/7095194532626563109)

3、[commonJS和ES导入导出的写法](https://zhuanlan.zhihu.com/p/301326042)

4、[ES之export default内部结构分析](https://juejin.cn/post/6898995481419251720)

5、[ES Module禁用export default](https://zhuanlan.zhihu.com/p/97335917)

6、[一篇不是标题党的CommonJS和ES模块](https://github.com/LinDaiDai/niubility-coding-js/blob/master/JavaScript/ES6%2B/%E4%B8%80%E7%AF%87%E4%B8%8D%E6%98%AF%E6%A0%87%E9%A2%98%E5%85%9A%E7%9A%84CommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E8%AE%B2%E8%A7%A3.md)

7、[babel入门](https://closertb.site/blog/59?cursor=Y3Vyc29yOnYyOpK5MjAyMC0wOC0xMlQxMzozNzoxOCswODowMM4oYFeQ)