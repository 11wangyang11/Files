高阶组件（Higher-Order Component，HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 本质上是一个函数，它接收一个组件并返回一个新的组件。

## 一、HOC VS Hook
示例：创建一个HOC，用于给组件添加一个额外的prop（比如用户信息）
```js
import React from 'react';

// 高阶组件函数，接收一个组件作为参数
function withUserInfo(WrappedComponent) {
  // 返回一个新的组件
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        userInfo: null
      };
    }

    componentDidMount() {
      // 假设这里有一个获取用户信息的函数
      fetchUserInfo().then(userInfo => {
        this.setState({ userInfo });
      });
    }

    render() {
      // 将额外的prop和原有的props一起传递给被包装的组件
      return <WrappedComponent userInfo={this.state.userInfo} {...this.props} />;
    }
  };
}

// 使用HOC
class MyComponent extends React.Component {
  render() {
    const { userInfo } = this.props;
    return (
      <View>
        {userInfo ? <Text>Hello, {userInfo.name}</Text> : <Text>Loading...</Text>}
      </View>
    );
  }
}

// 用HOC增强MyComponent
const EnhancedMyComponent = withUserInfo(MyComponent);
```
注意事项：
1. 不要改变原始组件，使用组合。也就是说，不要在HOC内部修改传入组件的原型（或任何其他方式改变它）。
2. 将不相关的props传递给被包裹的组件。HOC应该完全透传与自身无关的props。
3. 最大化可组合性。有时候一个HOC并不足够，用户可能会使用多个HOC增强一个组件。确保HOC的链式调用是合理的。
4. 包装显示名称以便调试。为了方便在React Developer Tools中调试，可以设置HOC返回组件的displayName，以便知道它是哪个HOC包裹的。

设置displayName的示例：
```js
function withUserInfo(WrappedComponent) {
  class WithUserInfo extends React.Component {
    // ...同上
  }
  // 设置显示名称
  WithUserInfo.displayName = `WithUserInfo(${getDisplayName(WrappedComponent)})`;
  return WithUserInfo;
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}
```
**需要注意的是，由于HOC会返回一个新的组件，所以每次渲染都会进行重新挂载，这可能会导致性能问题。因此，在HOC中应该注意避免在每次渲染时都创建新的HOC，而是应该尽量在组件外部定义HOC，以便在多次渲染中重用。**
其次，虽然高阶组件既能包装类组件，也能包装函数组件。但高阶组件最初提出是用于类组件的逻辑复用。现在函数组件更加推荐Hook，因为Hooks提供了更灵活和直观的方式来复用逻辑。比如上面示例使用hook代替，同样可以实现组件内部逻辑的复用：

**使用 Hook 取代 HOC（获取用户信息）**
```js
import React, { useEffect, useState } from 'react';
import { View, Text } from 'react-native';

// 可复用的逻辑：获取用户信息
function useUserInfo() {
  const [userInfo, setUserInfo] = useState(null);

  useEffect(() => {
    let isMounted = true;
    // 复用与 HOC 中相同的请求逻辑
    fetchUserInfo()
      .then(info => {
        if (isMounted) setUserInfo(info);
      })
      .catch(() => {
        if (isMounted) setUserInfo(null);
      });
    return () => {
      isMounted = false;
    };
  }, []);

  return userInfo;
}

// 使用示例：函数组件直接消费 Hook
function MyComponentWithHook(props) {
  const userInfo = useUserInfo();
  return (
    <View>
      {userInfo ? <Text>Hello, {userInfo.name}</Text> : <Text>Loading...</Text>}
    </View>
  );
}
```

这里就介绍一下HOC的核心特点：
1. 参数为组件，返回值也是组件
2. 不修改原组件，而是组合新组件
3. 通过 props 传递数据

## 二、场景举例

1. 这里再举一个例子：
```js
import React from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

// 高阶组件：添加加载状态
const withLoading = (WrappedComponent) => {
  return class extends React.Component {
    render() {
      const { loading, ...props } = this.props;
      
      if (loading) {
        return (
          <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
            <ActivityIndicator size="large" color="#0000ff" />
            <Text>加载中...</Text>
          </View>
        );
      }
      
      return <WrappedComponent {...props} />;
    }
  };
};

// 使用高阶组件
const MyComponent = (props) => (
  <View>
    <Text>{props.data}</Text>
  </View>
);

const MyComponentWithLoading = withLoading(MyComponent);

// 使用
<MyComponentWithLoading loading={true} data="示例数据" />
```

2. redux的connect也是一个高阶组件，如下：
```js
import { connect } from 'react-redux';

const mapStateToProps = (state) => {
  return {
    todos: state.todos
  };
};

const mapDispatchToProps = (dispatch) => {
  return {
    addTodo: (text) => dispatch({ type: 'ADD_TODO', text })
  };
};

const ConnectedComponent = connect(
  mapStateToProps,
  mapDispatchToProps
)(MyComponent);
```
# 1、内部原理
1. 创建高阶组件
connect 函数返回一个高阶组件，这个高阶组件会订阅 Redux store 的状态变化。当状态发生变化时，会重新计算传递给包裹组件的 props，并重新渲染组件。

2. 订阅 store
在返回的高阶组件内部，当组件挂载时，会订阅 Redux store。这样，每当 store 的状态发生变化时，就会触发一个回调函数，该函数会检查组件是否需要重新渲染。

3. 映射状态和 dispatch
connect 通过 mapStateToProps 和 mapDispatchToProps 将 store 中的状态和 dispatch 方法映射到组件的 props。

mapStateToProps: 一个函数，接收整个 Redux store 的状态作为参数，返回一个对象，这个对象将作为 props 传递给被包裹的组件。

mapDispatchToProps: 可以是一个函数或对象。如果是函数，它接收 dispatch 作为参数，返回一个包含 action 创建函数的对象。如果是对象，则每个函数都被视为一个 action 创建函数，connect 会自动用 dispatch 包装它们。

4. 性能优化
connect 会对 mapStateToProps 和 mapDispatchToProps 的结果进行缓存，并且只在相关的状态发生变化时才重新计算。它还会对传递给包裹组件的 props 进行浅比较，以避免不必要的重新渲染。

# 2、源码解析（简化版）
以下是一个极简版的 connect 实现，用于说明其原理：
```js
function connect(mapStateToProps, mapDispatchToProps) {
  return function(WrappedComponent) {
    return class ConnectedComponent extends React.Component {
      static contextType = ReactReduxContext; // 使用 React 的 Context 获取 store

      constructor(props) {
        super(props);
        this.state = {
          storeState: this.getStoreState()
        };
      }

      componentDidMount() {
        // 订阅 store 的状态变化
        this.unsubscribe = this.context.store.subscribe(() => {
          this.setState({
            storeState: this.getStoreState()
          });
        });
      }

      componentWillUnmount() {
        this.unsubscribe();
      }

      getStoreState() {
        return this.context.store.getState();
      }

      render() {
        const { store } = this.context;
        const stateProps = mapStateToProps(store.getState(), this.props);
        const dispatchProps = mapDispatchToProps(store.dispatch, this.props);

        return (
          <WrappedComponent
            {...this.props}
            {...stateProps}
            {...dispatchProps}
          />
        );
      }
    };
  };
}
```
