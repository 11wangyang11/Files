我们知道，在 react 中使用use开头的会识别为hook。在 react 中，自定义 Hook 是一种用于复用状态逻辑的机制，它让你可以提取组件逻辑到可重用的函数中。举个例子：

## 1、数据获取hook - useFetch
```js
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(response.statusText);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]); // 依赖项：url 变化时重新获取

  return { data, loading, error };
}
```

```js
function UserList() {
  const { data, loading, error } = useFetch('https://api.example.com/users');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {data?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## 2、自定义hook的本质
**自定义 Hook 本质上就是一个普通 JavaScript 函数，没有任何特殊的运行时行为。将 Hook 内部执行代码直接内联到组件函数体中，功能上确实完全等效。**
```js
function useActualHook() {
  const [count, setCount] = useState(0);
  useEffect(() => { /* 副作用 */ }, []);
  return count;
}

function MyComponent() {
  const count = useActualHook();
  // ...
}
```

**完全等价于：**
```js
function MyComponent() {
  const [count, setCount] = useState(0);
  useEffect(() => { /* 副作用 */ }, []);
  // ...
}
```

所以，自定义hook其实就是为了逻辑的复用。那为什么还使用use开头呢？
一方面是 eslint 会对 hook 进行识别，并检查其是否符合 hook 规范，比如：ESLint 会检查自定义 Hook 是否遵守：
1. 只在顶层调用 Hook（不能在条件语句、循环中）
2. Hook 的调用顺序必须一致
3. 正确处理依赖数组

其他方面，比如代码的可读性等等。


# 1、 自定义 Hook 本质：
    1. 普通 JavaScript 函数 
    2. 无特殊存储机制
    3. 每次渲染都会重新执行

# 2、 与官方 Hook 的关系：
    1. 自定义 Hook 内部的官方 Hook 会被添加到组件 Hook 链表
    2. 链表位置决定 Hook 身份
    3. 自定义 Hook 本身不在链表中

## 3、designToken hook - useIonicTokenStyle
```js
import React, { useContext, useMemo } from 'react';

// 1. 设计令牌上下文
const DesignTokenContext = React.createContext();

// 2. 设计令牌提供者组件
export const DesignTokenProvider = ({ tokens, children }) => {
  return (
    <DesignTokenContext.Provider value={tokens}>
      {children}
    </DesignTokenContext.Provider>
  );
};

// 3. 核心 Hook：useIonicTokenStyle
export const useIonicTokenStyle = (styleFactory) => {
  const tokens = useContext(DesignTokenContext);
  
  if (!tokens) {
    throw new Error('useIonicTokenStyle must be used within a DesignTokenProvider');
  }
  
  // 递归替换设计令牌为实际值
  const resolveTokens = (obj) => {
    if (!obj || typeof obj !== 'object') return obj;
    
    return Object.entries(obj).reduce((acc, [key, value]) => {
      // 如果是字符串且是设计令牌，则替换
      if (typeof value === 'string' && value in tokens) {
        acc[key] = tokens[value];
      } 
      // 如果是对象，则递归处理
      else if (typeof value === 'object' && value !== null) {
        acc[key] = resolveTokens(value);
      } 
      // 其他情况直接保留
      else {
        acc[key] = value;
      }
      return acc;
    }, {});
  };
  
  // 使用 useMemo 优化性能
  return useMemo(() => {
    const styleObject = styleFactory();
    return resolveTokens(styleObject);
  }, [styleFactory, tokens]);
};

// 4. 设计令牌值转换函数
export const createTokenValue = (value) => {
  if (typeof value === 'string' && value.startsWith('var(')) {
    return value;
  }
  return `var(--${value})`;
};

// 5. CSS 变量提供者组件
export const CSSVariablesProvider = ({ tokens, children }) => {
  const cssVariables = Object.entries(tokens).reduce((acc, [key, value]) => {
    acc[`--${key}`] = value;
    return acc;
  }, {});
  
  return (
    <div style={cssVariables}>
      {children}
    </div>
  );
};
```
