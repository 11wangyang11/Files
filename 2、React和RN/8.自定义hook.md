我们知道，在 react 中使用use开头的会识别为hook。在 react 中，自定义 Hook 是一种用于复用状态逻辑的机制，它让你可以提取组件逻辑到可重用的函数中。举个例子：

## 1、数据获取hook - useFetch
```js
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(response.statusText);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]); // 依赖项：url 变化时重新获取

  return { data, loading, error };
}
```

```js
function UserList() {
  const { data, loading, error } = useFetch('https://api.example.com/users');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {data?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## 2、自定义hook的本质
**自定义 Hook 本质上就是一个普通 JavaScript 函数，没有任何特殊的运行时行为。将 Hook 内部执行代码直接内联到组件函数体中，功能上确实完全等效。**
```js
function useActualHook() {
  const [count, setCount] = useState(0);
  useEffect(() => { /* 副作用 */ }, []);
  return count;
}

function MyComponent() {
  const count = useActualHook();
  // ...
}
```

**完全等价于：**
```js
function MyComponent() {
  const [count, setCount] = useState(0);
  useEffect(() => { /* 副作用 */ }, []);
  // ...
}
```

所以，自定义hook其实就是为了逻辑的复用。那为什么还使用use开头呢？
一方面是 eslint 会对 hook 进行识别，并检查其是否符合 hook 规范，比如：ESLint 会检查自定义 Hook 是否遵守：
1. 只在顶层调用 Hook（不能在条件语句、循环中）
2. Hook 的调用顺序必须一致
3. 正确处理依赖数组

其他方面，比如代码的可读性等等。


# 1、 自定义 Hook 本质：
    1. 普通 JavaScript 函数 
    2. 无特殊存储机制
    3. 每次渲染都会重新执行

# 2、 与官方 Hook 的关系：
    1. 自定义 Hook 内部的官方 Hook 会被添加到组件 Hook 链表
    2. 链表位置决定 Hook 身份
    3. 自定义 Hook 本身不在链表中

## 3、designToken hook - useIonicTokenStyle
todo，写的不好，调整一下
```js
import React, { useContext, useMemo } from 'react';

// 1. 设计令牌上下文
const DesignTokenContext = React.createContext();

// 2. 设计令牌提供者组件
export const DesignTokenProvider = ({ tokens, children }) => {
  return (
    <DesignTokenContext.Provider value={tokens}>
      {children}
    </DesignTokenContext.Provider>
  );
};

// 3. 核心 Hook：useIonicTokenStyle
export const useIonicTokenStyle = (styleFactory) => {
  const tokens = useContext(DesignTokenContext);
  
  if (!tokens) {
    throw new Error('useIonicTokenStyle must be used within a DesignTokenProvider');
  }
  
  // 递归替换设计令牌为实际值
  const resolveTokens = (obj) => {
    if (!obj || typeof obj !== 'object') return obj;
    
    return Object.entries(obj).reduce((acc, [key, value]) => {
      // 如果是字符串且是设计令牌，则替换
      if (typeof value === 'string' && value in tokens) {
        acc[key] = tokens[value];
      } 
      // 如果是对象，则递归处理
      else if (typeof value === 'object' && value !== null) {
        acc[key] = resolveTokens(value);
      } 
      // 其他情况直接保留
      else {
        acc[key] = value;
      }
      return acc;
    }, {});
  };
  
  // 使用 useMemo 优化性能
  return useMemo(() => {
    const styleObject = styleFactory();
    return resolveTokens(styleObject);
  }, [styleFactory, tokens]);
};
```

举例：
```js
const tokenStyles = {
  button: { 
    backgroundColor: 'color-primary',
    padding: '12px' 
  },
  text: { 
    backgroundColor: 'color-primary-dark'
  }
}
```
token:
```js
// 设计令牌
const tokens = {
  'color-primary': '#4285f4',
  'color-primary-dark': '#3367d6'
};
```
结果：
```js
const style = useIonicTokenStyle(tokenStyles);
// {
//   button: {
//     backgroundColor: '#4285f4', // 令牌替换为实际值
//     padding: '12px'               // 非令牌值保留
//   },
//   text: {
//     backgroundColor: '#3367d6' // 令牌替换为实际值
//   }
// }
```


## 4、登陆
```tsx
import { useCallback } from 'react'
import { xUser } from '@ctrip/xtaro'

interface IUseLoginStatus {
    /**
     * 打开登录浮层
     */
    openLoginLayer: () => void
    /**
     * 是否已登录
     */
    isLogin: boolean
}

/**
 *
 */
interface IUserLoginProps {
    /**
     * 是否强制登录
     */
    forceLogin?: boolean
    /**
     * 登录成功
     */
    loginSuccess?: () => void
    /**
     * 登录失败
     */
    loginFailure?: () => void
}

export const useLoginStatus = (props: IUserLoginProps): IUseLoginStatus => {
    const { forceLogin = false, loginSuccess = (): void => {}, loginFailure = (): void => {} } = props
    const isLogin = xUser.isLogin()
    const openLoginLayer = useCallback(() => {
        //会员登录
        xUser.login({
            callback: (res) => {
                if (res.result) {
                    //登录成功
                    void loginSuccess()
                } else {
                    void loginFailure()
                }
            },
        })
    }, [forceLogin, loginFailure, loginSuccess])

    return { openLoginLayer, isLogin }
}
```
