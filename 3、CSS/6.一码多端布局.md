### 一、RN和H5布局差异
## 1、内容
1、web(react/css)支持 `Flex/Grid/Float/Table` 等，而react-native只支持`Flex`布局；
2、web还支持`static、fixed、absolute、relative`等定位，而react-native则只提供了绝对定位：`position: 'absolute'`（总是相对于直接父组件）和相对定位`position: 'relative'`；
3、web支持`block、inline-block、inline`等基础布局，而react-native不支持。

为了兼容多端，整体采用**flex布局+绝对定位**这个子集。其次，react-native的绝对布局与web绝对布局的相对位置不一样，react-native是相对父组件，web则以设置了`position: relative/absolute`的父组件定位。所以，设置绝对布局的同时需要在父组件设置`position: relative`兼容web。

## 2、原因
1、rn使用的是yoga引擎，约束了布局方式为flexbox。单一 Flexbox 模型配合自顶向下的同步计算，能实现最少的跨线程通信。所以rn子组件总是相对父组件定位，减少回流（重新运行 Yoga 布局计算）导致的通信成本，而且与iOS/android布局方式也保持一致；
2、但是，Web 的多种布局模型之间存在复杂的相互依赖，需要多次测量和调整，容易导致“布局抖动”等问题。

### 二、RN和H5样式比较
## 1、内容
1、flexDirection：react-native默认 column，h5 和小程序默认 row，所以要显式设置（项目中h5设置了div的全局display: 'flex'和flexDirection:'column'）；
2、css样式：只用 class 选择器，react-native不支持其他选择器（css规范：https://pages.release.ctripcorp.com/xtaro/xtaro/docs/advanced/writing_styles）；
3、XText：web上编译成span内联元素，所以不要在XText组件上设置margin、padding，在react-native端有效，web端无效。其次，textAlign可以对<Text>进行对齐，而对<span>行内元素无效，需要如justify-content等对齐；
4、XIconView：XIconView编译是文本标签，不要外包View组件，否则无法嵌套在文本组件里面（需要testid的话放在外层容器里）；
5、ScrollView：web的滚动需要设置固定高度，设置百分比不行，而react-native可以设置百分比。 react-native中，overflow: 'auto' 可能会让滚动区域脱离原生滚动容器的布局，导致内容溢出并覆盖上下组件，而在web 端需要 overflow: 'auto'设置滚动；
6、数组样式：react-native的数组样式style={[style1, style2]}，在web上不支持，会直接报错；
7、lineheight：设置了全局的“1”替代默认值，解决icon不对齐问题。

## 2、原因
1、h5小程序，受PC端习惯影响，保持flexDirection默认row的排列方式，rn则遵循iOS/android原生开发的垂直排列方式；
2、rn只支持class选择器，不支持其它复杂的选择器，是因为rn是将其解析成js对象，发送到native层。RN 的 "class" 只是简单的键值引用，用于组件查找样式，不是真正的 CSS 类选择器：
    a. 缺少元素关系匹配（父子、兄弟、后代等）
    b. 缺少状态伪类匹配（:hover、:active 等）
    c. 缺少属性选择器匹配（[type="text"] 等）
    d. 缺少复杂的选择器解析和树遍历
```js
// Web: 声明式选择器匹配
// "找到所有符合 .parent .child 的元素并应用样式"

// RN: 命令式样式引用  
// "给这个特定组件应用这个特定样式对象"
```

### 三、xtrao默认设置
xtaro多端组件存在很多默认样式（相比rn几乎没有默认样式），比如：
1、XButton在web端存在border-width为1，并且XButton在web端存在border伪类设置，需要覆盖（borderStyle、borderWidth等覆盖不了，取消页设置了.weui-btn:after {border: none !important;}进行了覆盖）；
2、在react-native中，组件的position属性默认值是relative， web默认为static；
3、等等。
总之，由于不确定默认样式的影响，所有改动需要在多端测试一下效果（xtaro项目可以同时启动h5、rn，对比开发），保证默认以及不同的编译结果不影响最终的样式。

### 四、其他问题
由于xtaro组件的实现方式、多端的环境配置等，可能会出现各种其他问题：
1、iconfont没有加载出来，调整了一下配置的写法；
2、组件使用：依赖没有注入，往往是组件调用方没有显示`import`依赖时，打包时会移除该依赖，导致组件运行出问题（peerDependencies）；
3、`export const enum`意味着在 TypeScript 编译时，枚举将被内联到使用它的地方；使用的是普通的 `export enum`，在编译后的 JavaScript 中会生成一个对象。枚举定义与导出是分开的，先定义枚举，然后通过如 `export { EOrderPriority }` 导出，这种情况编译可能会丢失该对象；
4、h5的所有url需要https，否则会被拦截，测试环境也如此。


使用peerDependencies优点：
1. 避免版本冲突：让应用项目统一管理核心库的版本
2. 减少包体积：不会重复安装相同的依赖
3. 符合 React Native 生态惯例：大部分知名库都使用 peerDependencies