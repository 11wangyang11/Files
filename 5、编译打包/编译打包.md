我们都知道，无论是nodejs项目还是web端的Javascript项目，都需要编译成对应的版本和模块，来适配其最终的运行环境。通常，我们是通过配置`tsconfig.json`文件以及Babel等编译工具。

### 一、tsconfig
```ts
// tsconfig.json文件
{
  "compilerOptions": {
    "target": "es6", // javascript版本
    "module": "CommonJS", // 模块系统
    "lib": ["ES2021"], // 要包含ES2021库
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"], // 编译的文件
  "exclude": ["node_modules", "**/*.spec.ts"] // 不编译的文件(优先级高于include)
}
```
上面是某Node.js项目中的`tsconfig.json`文件。这里针对`tsconfig.json`文件的“target”和“module”，详细介绍一下。
## 1、配置介绍
# （1）target
`target`指的是代码编译后的javascript版本，比如ES6支持箭头函数、let 和 const 声明等，则需要这意味着编译后的代码需要在支持 ES6 的环境中运行。这里要注意“是编译后”，编译前的项目代码自然可以使用任何最新的javascript语法。 

既然如此，是不是`target`版本越低越好？这样就可以支持更多的js环境了。虽然设置较低的版本（如 ES3 或 ES5）可以使编译后的代码在更多的旧环境中运行，但这并不总是最佳选择。一方面，使用较低版本的 target 会导致编译器将现代语法转换为较旧的等效代码，这可能会使编译后的代码变得冗长且难以阅读。例如，箭头函数会被转换为传统的函数表达式，let 和 const 会被转换为 var，这可能会影响代码的可读性和调试体验。另一方面，较低版本的 target 可能不支持一些现代 JavaScript 特性，这些特性可能在性能和功能上有显著优势。例如，ES6 引入了 Promise、async/await、模块系统等，这些特性在现代 JavaScript 开发中非常有用。如果将 target 设置为较低版本，可能需要引入 polyfills 或其他替代方案来实现这些功能，这可能会增加代码的复杂性和体积。

# （2）module
`module`指定编译后的代码将使用哪种模块加载和组织方式。例如，CommonJS 使用 require 和 module.exports，而 ES6 模块系统使用 import 和 export。比如上述`tsconfig`配置（`"target": "es6","module": "CommonJS"`）针对下面代码：
```ts
const greet = (name: string) => {
  console.log(`Hello, ${name}!`);
};
export default greet;
```
编译后的 JavaScript 代码为：
```js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true }); // 给exports增加__esModule属性，表示这个 CJS 包是从 ES Module 转出来的，默认导出在 exports.default 上
const greet = (name) => {
    console.log(`Hello, ${name}!`);
};
exports.default = greet;
```
所以，该文件导出的是`{default: greet, __esModule: true}`。在这个例子中，编译后的 JavaScript 代码使用了 ES6 的箭头函数和模板字符串（因为 target 设置为 ES6），同时使用了 CommonJS 的模块系统，如exports.default = greet;（因为 module 设置为 CommonJS）。如果使用`module: 'es6'`，则编译结果如下：
```js
const greet = (name) => {
    console.log(`Hello, ${name}!`);
};
export default greet;
```

**举例**
我们经常使用如下代码：
```js
const module = require('./module')
const Tag = module && module.__esModule ? module.default : module
export default Tag
```
其实这是CommonJS导入的两种场景，如果是CommonJS的`exports.default = greet;`导出(判断__esModule为true)，则使用`require('./module').default;`的方式导出；如果是CommonJS的`module.exports = someFunction;`的方式导出，则`require('./module')`就是导出的对象。但是如果是ES Module模块导出，则require会报错，所以使用上面方式导入，理论上项目的tsconfig.json的module得是CommonJS版本。但是，很奇怪的是我tsconfig.json配置的是`"module": "es2020"`，但是却没有报错，可以正常使用。这是为什么呢？

这归功于打包器了，项目使用了Metro/Webpack 这类打包器，打包器会在构建阶段把 import/export 与 require 统一成自己的模块系统，并注入 CJS/ESM 互操作（含 esModule）逻辑，所以 require(...) 拿到的 ESM 源也能正常用。只有没有打包器的时候才会报错。我们项目编译后的产物是dist，里面是esm导出，而metor打包后的产物本地看不到，需要主动处理。

# (3) jsx
在 tsconfig.json 文件中，jsx 选项用于指定 TypeScript 如何处理 JSX 语法。以下列举了 jsx 几种常用设置及其含义：
1. "preserve": 保留 JSX 语法，不进行转换。这意味着你需要一个后续的编译步骤（通常是 Babel）来处理这些 JSX 语法。
2. "react": 将 JSX 语法转换为 React.createElement 调用。适用于传统的 React 项目和 React-Native 项目，需要显式导入 React。
3. "react-jsx": 使用新的 JSX 转换机制，将 JSX 语法转换为 jsx 函数调用，不需要显式导入 React。适用于使用 React 17 及以上版本的项目，简化代码。

## 2、兼容性和使用场景
1、Node.js 环境: Node.js 支持 ES6 的大部分语言特性，并且默认使用 CommonJS 模块系统。因此，target: "ES6" 和 module: "CommonJS" 是一个常见的组合，这有历史原因也有CommonJS在Node.js中的优势。比如 CommonJS 模块系统是同步加载的，这与 Node.js 的单线程、事件驱动架构非常契合。同步加载使得模块在加载时可以立即使用，这对于服务器端应用程序来说非常方便，因为它们通常在启动时加载所有必要的模块。

2、前端环境: 浏览器环境通常使用 ES6 模块系统（import 和 export），但可以通过构建工具（如 Webpack、Babel）将 ES6 模块转换为其他模块系统（如 UMD 或 CommonJS），以实现兼容性。你可能疑惑，既然`tsconfig`已经可以配置编译后的javascript版本和模块系统了，为什么还需要Babel等编译工具呢？其实，对于很多项目如nodejs项目，一般就用只用`tsconfig`。但是Babel、Webpack有更加强大的功能，比如Webpack\Babel可以优化包size，Babel支持最新的 ECMAScript 标准和实验性特性，并且他们还可以通过插件扩展功能等。下面会进行介绍(后续展开介绍)！

最后，关于使用CommonJS或者ES6等不同模块系统的问题，具体见“模块化”文档。

### 二、Webpack/metro
metro是react-native的默认打包工具，webpack是web的默认打包工具。`Webpack`和`metro`打包工具在打包时会进行静态分析，没有被引用到的模块时不会被打包进最终的输出文件的。
## 1、分包
# (1) require
1. 模块系统：require 是 CommonJS 模块系统的一部分，最初用于 Node.js。
2. 同步加载：require 是同步的，这意味着模块在调用时立即加载并执行。
3. 动态加载：require 可以在代码执行过程中动态加载模块。这意味着您可以根据条件决定是否加载某个模块。
4. Node.js 环境：require 在 Node.js 中广泛使用，但在浏览器环境中不直接支持，但通过使用工具（如 Browserify 或 Webpack），可以将 CommonJS 模块转换为浏览器兼容的代码。

因为 Node.js 运行在服务器端，它可以在运行时访问文件系统并根据需要加载模块。所以，在 Node.js 环境中，如果条件不满足，require 语句不会被执行，模块不会被加载。但是，前端需要打包，所以只能在静态分析阶段判断模块是否需要打包到增量中。通常，require模块都会被打包进bundle中，且不会分包。

# (2) import()
1. 模块系统：import 是 ES6（ES2015）引入的模块系统的一部分，是现代 JavaScript 的标准。
2. 静态分析：import 是静态的，模块在编译时就被解析。这允许工具进行更好的优化，如 tree-shaking。
3. 顶层使用：import 必须在模块的顶层使用，不能在条件语句或函数中动态调用。
4. 广泛支持：现代浏览器和工具链（如 Babel 和 Webpack）都支持 ES6 模块。

还有一点，对于动态加载和代码分割，在现代前端开发中推荐使用 `import()` 语法（ES6语法）。在使用动态 `import()` 语法时，Webpack 会将被动态导入的模块视为代码分割点。这意味着这些模块会被打包成单独的代码块（chunk），这些代码块会在运行时通过网络请求按需加载，而不是包含在主代码包中。这种方式允许按需加载模块，而不是在应用启动时加载所有代码。
```js
import('./module').then(module => {
  // 使用模块
  const myModule = module.default;
});
```

但是，Metro 是 React Native 的打包工具，它与 Webpack 有一些不同的特性。Metro 目前不支持像 Webpack 那样的动态 import() 进行代码分割和按需加载。它将所有 JavaScript 代码打包成一个 bundle 文件，以便在移动设备上高效加载。

**metro与webpack比较：**
-------------------------------------------------------------------------------------------------------
导出方式 × 打包配置	       Webpack (tree-shaking)	      Metro(开InlineRequire)	  Metro(关InlineRequire)
-------------------------------------------------------------------------------------------------------
ES Module 导出            ✅ 按需打包(Tree-shaking生效)    ❌ 全量打包                 ❌ 全量打包
import {A} from '@test'	 ❌ 立即加载                     ✅ 按需加载                 ❌ 立即加载
                         
-------------------------------------------------------------------------------------------------------
Getter 导出方式            ❌ 全量打包(Tree-shaking无效)   ❌ 全量打包                 ❌ 全量打包
                         ✅ 按需加载                     ✅ 按需加载                 ✅ 按需加载
-------------------------------------------------------------------------------------------------------
直接路径导入                ✅ 按需打包                    ✅ 按需打包                 ✅ 按需打包
import A from 
'@test/src/components/A'  ❌ 立即加载                    ✅ 按需加载                 ❌ 立即加载
-------------------------------------------------------------------------------------------------------

值得注意的是，针对ES Module 导出，Metro开启InlineRequire，并非完全没有tree-shaking功能。对于简单导出但未使用的模块，静态分析阶段，可能会被移除。如下：
```ts
// 这种情况 Metro 可能只打包 Page3
import Page3 from './Page3';
import Page4 from './Page4'; // 未使用，可能被移除

const config = {
  page: Page3 // 只使用了 Page3
};
```

这里对metro的静态分析能力做一个分析：
# 1、情况1：直接导入具体路径
```ts
import PriceInfo from '@ctrip/xtaro-hotel-components-crn/src/components/price-info'
```
Metro 的分析过程：
1. 解析 import 语句，找到目标文件 ./src/components/price-info
2. 分析该文件的依赖关系
3. 只打包 price-info 组件及其直接依赖

# 2、通过动态 getter 导入
```ts
import PriceInfo from '@ctrip/xtaro-hotel-components-crn'
```
```ts
// 组件index.ts
const CRN = {
  get PriceInfo() {
    const module = require('./src/components/price-info');
    return module.default;
  },
  get SegmentControl() {
    const module = require('./src/components/segment-control');
    return module.default;
  }
}
```
Metro 也无法在静态阶段确定我们不会使用 CRN.SegmentControl。因为 CRN 对象被导出，其他模块可能以“动态方式”使用它。因此，Metro 会保守地将所有可能用到的模块都打包。比如下面代码就用到了SegmentControl，但是静态分析分析不出来：
```ts
// 或者通过循环访问所有组件
Object.keys(CRN).forEach(key => {
    const Component = CRN[key]; // 可能访问所有getter
    // 做一些操作...
});
```
Metro 的按需打包依赖于静态分析，而 getter 函数和动态 require 破坏了静态可分析性。为了获得最佳的 tree-shaking 效果，应该使用直接的 ES6 模块导出语法。


## 2、lib / es / dist

（1）`dist` 是Webpack/metro的产物；`es`和`lib`是`react`或者`react native`项目中两个常见的文件夹，用于存放 JavaScript 代码;   

（2）`es`文件夹中存放的是经过Babel转译后的`ESModules代码`;   
  
（3）`lib`文件夹中存放的是经过Babel转译后的`CommonJS代码`;  

通常，在`React Native`项目中，开发者可以选择使用 `es` 文件夹中的代码进行开发和调试，而将 `lib` 文件夹中的代码用于构建和发布应用程序。这样可以在开发过程中享受到更好的开发体验，同时在生产环境中获得更好的兼容性。

## 3、引入es还是lib？

如果我们使用一个依赖，且该依赖目录包含`es`和`lib`两个文件。那使用`import` 引入就是使用 `es`文件夹下内容，`require` 引入就是使用 `lib`文件夹下内容。   

可以试验一下，我们引入一个`npm依赖`，如果使用 vscode 点击会发现跳转到了`lib`文件下，是因为 vscode 默认是 node 环境，链接时按照 `require` 来链接；但最终打包 Webpack 是依据你当前导入语句来决定的。目前，开发基本都是使用 ES6，即使用 import 的方式导入模块，并使用 Babel 进行向下兼容。在 Node.js 中，模块是通过 CommonJS 规范来定义和导出的。虽然从 Node.js 12 版本开始，Node.js 已经开始支持 ES Modules 了。但是，Node.js 仍然默认使用 CommonJS 规范来加载模块。如果你想在 Node.js 中使用 ES Modules，需要在文件中添加 `.mjs` 扩展名，并使用 `--experimental-modules` 标志来启用实验性的 ES Modules 功能。

### 三、Babel
## 1、babel的转换
首先，ES6的升级地方有很多，比如箭头函数、类、模板字符串、解构、等，参数默认值、let/const、for…of、map/set等（详情见https://www.babeljs.cn/docs/learn）。babel会对一些新句法做转换，比如箭头函数、类、let/const等。需要注意的是，Babel 默认只转换新的 JavaScript 句法，而不转换新的 API，比如`Iterator`、`Generator`、`Set`、`Map`、`Proxy`、`Reflect`、`Symbol`、`Promise`等全局对象，以及一些定义在全局对象上的方法（比如`Object.assign`）都不会转码。不过，Babel提供了polyfill来转换这些类型。

举例来说，ES6 在`Array`对象上新增了`Array.from`方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用`babel-polyfill`，为当前环境提供一个垫片。否则比如代码：   

`colors = Array.from(str.matchAll(regex), match => match[1]);`   

在commonJS环境下会报错。(polyfill 配置方式见[bable配置polyfill](https://www.babeljs.cn/docs/babel-preset-env))。但是，polyfill会增加额外的空间和性能开销！

## 2、ES6新增API
ES6新增的API有Map、Set、Promise等，新增的API方法有很多，分类如下：
# 1、数组（Array）新增 API
Array.from()	将类数组对象或可迭代对象转为数组。
Array.of()	创建一个包含任意数量元素的新数组。
arr.find(callback)	返回第一个符合条件的元素。
arr.findIndex(callback)	返回第一个符合条件的元素的索引。
arr.fill(value)	用固定值填充数组。
arr.copyWithin()	复制数组的一部分到同一数组的另一位置。
arr.entries()	返回数组的键值对迭代器。
arr.keys()	返回数组的键（索引）迭代器。
arr.values()	返回数组的值迭代器。
# 2、对象（Object）新增 API
Object.assign(target, ...sources)	合并多个对象的属性到目标对象（浅拷贝）。
Object.is(value1, value2)	更严格的相等性比较（替代 ===）。
Object.setPrototypeOf(obj, prototype)	设置对象的原型。
Object.getPrototypeOf(obj)	获取对象的原型。
Object.keys() / Object.values() / Object.entries()	返回对象自身可枚举属性的键、值、键值对。
# 3、函数（Function）新增特性
箭头函数	() => {}，简化函数语法，绑定 this。
参数默认值	function(a = 1) {}
剩余参数	function(...args) {}
扩展运算符	Math.max(...array)
# 4、字符串（String）新增 API
str.startsWith(search)	检查字符串是否以某个子串开头。
str.endsWith(search)	检查字符串是否以某个子串结尾。
str.includes(search)	检查字符串是否包含某个子串。
str.repeat(n)	重复字符串 n 次。
模板字符串	`Hello ${name}`，支持多行和插值。

# 5、数字（Number）新增 API
Number.isNaN()	更安全的 NaN 检测。
Number.isFinite()	检查是否为有限数。
Number.isInteger()	检查是否为整数。
Number.EPSILON	表示最小精度（用于浮点数比较）。
Math.trunc()	去除小数部分（直接截断）。
Math.sign()	返回数值的符号（正、负、零）。

# 6、其他新增 API
Symbol	Symbol()	创建唯一的值，用作对象属性的键。
迭代器（Iterator）	[Symbol.iterator]	定义对象的迭代行为（如 for...of）。
生成器（Generator）	function* 和 yield	生成迭代器的函数。
模块化（Module）	import / export	模块导入导出语法。


## 3、babel常见依赖
# (1) 基础依赖
1. @babel/core： Babel 的核心引擎，负责代码解析、转换和生成。

# (2) 预设（Presets）
预设将多个 Babel 插件打包成一个集合，无需手动逐个添加插件。常见预设有：
1. @babel/preset-env：自动根据目标环境转译 ES6+ 代码。
2. @babel/preset-react：支持 React 的 JSX 语法。
3. @babel/preset-typescript：支持 TypeScript。
4. @babel/preset-flow：	支持 Flow 类型检查语法。

预设（Presets）需要在 Babel 的配置文件中声明（如 babel.config.json、.babelrc 或其他支持的配置文件格式）。
babel.config.json
```json
{
  "presets": [
    ["@babel/preset-env", { 
      "targets": "> 0.5%, last 2 versions", // 按需指定目标环境
      "useBuiltIns": "usage", // 按需引入 Polyfill
      "corejs": 3  // 指定 core-js 版本
    }],
    "@babel/preset-react"
  ]
}
```
