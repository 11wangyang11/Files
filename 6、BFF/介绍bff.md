`bff`(backend for frontend)，前端的后端。首先，服务端的出现就是随着前端逻辑和后端业务越来越复杂，传统的前端直接与后端联系的方式，使得前端需要处理大量的数据转换和组装，后端接口的设计可能无法满足前端的需求等。所以发展出的分工主要是：
1. 后端：专注于业务，与数据库打交道等；
2. 前端：专注于渲染和交互；
3. 服务端：作为前端和后端的桥梁，处理各种请求、数据存储等工作。

### 一、bff优缺点
## 1、优点
在多端统一的趋势下，我们开始引入`bff`。因为，多端统一场景下，一个前端团队会负责多端页面，导致其服务团队越来越难以满足前端的多端需求。我认为，`bff`至少解决了以下几个问题：  

1. 多端统一场景下，前端团队对多端的认识和熟悉程度远远大于服务团队，所以由前端团队设计多端统一契约、组装多端数据更加合理；
2. 业务的膨胀，导致服务端本身也有更多的工作需要做；
3. 随着前端的逻辑越来越复杂，`bff`可以有效地将前端的`Modal`放在`bff`，这样，前端仅仅保留`View`和`Presenter`，且多端可以共享`Modal`层，因为多端统一场景下，多端往往存在很多一致的或者类似的`Modal`数据；
4. 得益于服务的强大能力，前端负责“前端+bff”的组合，意味着大前端系统变得可沉淀、可配置、可灵活应对各种变化。

## 2、缺点
但是，在开发中，`bff`也存在一些烦恼。首先，在整个链路上增加`bff`一环，加长了服务请求时长，也增大问题的排查难度等。而且，在现有服务基础上新增`bff`层，容易导致`bff`和服务端界线不清晰，前端、服务端分工不明，反而导致逻辑上更容易出错，且不利于后期维护。

## 3、分工
所以，`bff`和服务端的分工要明确，这里给出我的结论（不适用所有场景）:  

# (1) BFF
1. 前端开发主导前端的“变化”。数据下沉到BFF，并由前端自己主导；
2. 留给后端更清晰的服务边界，只需要提供粗粒度的接口即可。

# (2) 服务端
1. 处理复杂的业务逻辑，例如订单处理、支付流程、权限管理等，服务端根据业务需求进行数据处理、计算和验证，确保数据的完整性和安全性；
2. 数据库进行交互，进行数据的存储、查询和更新等操作，服务端需要保证多端数据的一致性和可靠性；
3. 负责用户身份验证、权限控制和安全认证工作等等。

### 二、bff框架
## 1、Node.js
首先，`bff`是前端团队维护，前端如果使用`javaScript`的话，那`bff`在语种上应该同样使用`javaScript`，比如基于`Node.js`开发。

**`Node.js`是什么？**

1. `Node.js`作为运行环境： 

`Node.js`是一个基于`Chrome V8`引擎的`JavaScript`运行环境。简单来说，它让你能够在服务器端运行`JavaScript`代码，而不仅仅是在浏览器中运行。`Node.js`提供了一套`API`，使得`JavaScript`可以与文件系统、网络等进行交互。

2. `Node.js`作为开发平台： 

`Node.js`不仅仅是一个运行环境，它还提供了大量的库和工具，使得开发者可以用`JavaScript`来构建服务器端应用程序。通过使用`Node.js`，你可以创建Web服务器、API服务、实时聊天应用等。

**那`Node.js`是否适合作为`bff`的开发平台？** 

现在公司很多使用`java、Go`进行服务端开发。如果需要高性能和高并发，`Go`是一个不错的选择。`Java`适合大项目，在企业中应用最广泛。如果需要快速开发和同构开发(都是`javascript`语言的缘故)，`Node.js`是一个很好的选择。对前端来说，再适合不过了。

## 2、NestJS 

`Node.js` 本身提供了一些基本的功能，但你需要写很多代码来处理常见的任务，比如 `HTTP` 请求、路由、依赖管理等。`NestJS` 在 `Node.js` 框架上进行了多层次的封装，以提供一个模块化、可扩展和易维护的开发环境。以`HTTP`请求为例，在`Node.js`上写法如下：
```js
const http = require('http');

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!\n');
});

server.listen(3000, '127.0.0.1', () => {
  console.log('Server running at http://127.0.0.1:3000/');
});
```  

在`NestJS`中，你只需要定义一个控制器（Controller）：
```js
import { Controller, Get } from '@nestjs/common';

@Controller('hello')
export class HelloController {
  @Get()
  getHello(): string {
    return 'Hello, world!';
  }
}
/**
 * 1. Controller：在 NestJS 中，控制器用于定义路由和处理请求。上面的 HelloController 类定义了一个 /hello 路由，当你访问 http://localhost:3000/hello 时，会返回 Hello, world!。
 * 2. 装饰器：@Controller('hello') 和 @Get() 是装饰器，用于简洁地定义路由和请求方法。
 * /
```

### 三、云函数
云函数（Cloud Functions）是一种无服务器（Serverless）计算服务，允许开发者编写和运行代码，而无需管理服务器。云函数通常由云服务提供商（如 AWS Lambda、Google Cloud Functions、Azure Functions）提供。 

## 1、云函数特点
1. 无服务器管理：开发者不需要管理底层的服务器资源，云服务提供商会自动处理扩展、负载均衡和服务器维护；
2. 按需执行：云函数通常是事件驱动的，只有在特定事件触发时才会执行，按实际使用量计费；
3. 高可扩展性：云函数可以根据需求自动扩展，以应对不同的负载；
4. 短生命周期：云函数通常是短时运行的，适合处理单一任务或事件。

从服务特点来看，`bff`使用云函数就非常合适。一方面，因为`bff`是为前端提供专门的 API，通常需要快速响应和按需扩展；另一方面，`bff`请求通常是用户行为触发的单一任务，且按使用量付费非常合理。

## 2、适合使用云函数的服务
**适合云函数的场景** 

1. 事件驱动的任务：处理文件上传、数据库变更、消息队列事件等。
2. 短暂的、无状态的任务：数据处理、图像处理、视频转码等。
3. 按需扩展的应用：高并发的`API`请求处理、微服务架构中的独立功能模块。
4. 定时任务和自动化：定时数据备份、定期报告生成、自动化运维脚本。
5. 快速原型和实验：快速部署和测试新功能、`A/B`测试。

**不适合云函数的场景** 

1. 长时间运行的任务：大规模数据迁移、复杂的数据分析任务。
2. 有状态的应用：需要持久连接的聊天应用、游戏服务器。
3. 高频率调用且需低延迟：实时交易系统、低延迟的金融应用。
4. 复杂依赖和环境配置：需要特定硬件或复杂软件环境的应用。
5. 高成本敏感的场景：持续高频调用可能导致成本高于传统服务器。

总的来说，云函数适用于各种需要无状态、按需执行和事件驱动的业务场景，如前端 `BFF` 服务、事件驱动的自动化任务等。

