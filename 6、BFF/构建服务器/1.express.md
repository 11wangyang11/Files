fetch和axios是发起网络请求，而express则是在nodejs后端接收和处理网络请求。我们首先看看使用原生nodejs响应服务请求。

## 1. 原生 Node.js HTTP 处理
原生http处理使用`createService`来创建 HTTP 服务器（官网：https://www.nodeapp.cn/http.html#http_class_http_agent）
```js
// Node.js 自带了一些核心模块，比如 `http`、`url`、`fs`、`path`等，可以直接通过 `require` 引入
const http = require('http');
const url = require('url');

// 创建 HTTP 服务器
const server = http.createServer((req, res) => {
  const { pathname, query } = url.parse(req.url, true);
  
  // 1. 处理 GET 请求
  if (req.method === 'GET') {
    if (pathname === '/') {
      res.writeHead(200, { 'Content-Type': 'text/plain' });
      res.end('Home Page'); // 每个响应都必须调用 res.end()，否则客户端会一直等待直到超时
    } 
    else if (pathname === '/about') {
      // 处理查询参数
      const name = query.name || 'Guest';
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ message: `Hello ${name}` }));
    }
    else {
      res.writeHead(404);
      res.end('Not Found');
    }
  }
  
  // 2. 处理 POST 请求
  else if (req.method === 'POST') {
    if (pathname === '/echo') {
      let body = '';
      
      // 手动收集请求体数据流
      req.on('data', chunk => {
        body += chunk.toString();
      });
      
      // 数据接收完毕
      req.on('end', () => {
        try {
          // 尝试解析 JSON
          const data = JSON.parse(body);
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ 
            received: true, 
            data 
          }));
        } catch (error) {
          res.writeHead(400);
          res.end('Invalid JSON');
        }
      });
    } else {
      res.writeHead(404);
      res.end('Not Found');
    }
  }
  
  // 3. 处理其他 HTTP 方法
  else {
    res.writeHead(405);
    res.end('Method Not Allowed');
  }
});

// 启动服务器
server.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

当然，http也可以发送服务请求，如下：


## 2、Express.js 实现（使用框架）
```js
// express 是一个第三方包，需要额外安装依赖
const express = require('express');
const app = express();

// 中间件：自动解析 JSON 请求体
app.use(express.json());

// 1. 处理 GET 请求
app.get('/', (req, res) => {
  res.send('Home Page');
});

app.get('/about', (req, res) => {
  // 自动处理查询参数
  const name = req.query.name || 'Guest';
  res.json({ message: `Hello ${name}` });
});

// 2. 处理 POST 请求
app.post('/echo', (req, res) => {
  // 自动解析的请求体数据
  res.json({ 
    received: true, 
    data: req.body 
  });
});

// 3. 处理未匹配路由 (404)
app.use((req, res) => {
  res.status(404).send('Not Found');
});

// 4. 统一错误处理
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Server Error');
});

// 启动服务器
app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

# 注释：
1、`app.use(express.json())` 是一个“数据翻译官”。当客户端通过 POST 或 PUT 请求，在请求体（Body） 里发送 JSON 格式的数据给服务器时，这个中间件能自动将其解析成 JavaScript 对象，并挂载到 req.body 上，这样你的路由处理代码就能直接使用了。
它的核心工作原理可以概括为：
1. 检查请求：判断请求头 Content-Type 是否为 application/json。
2. 解析数据：将传入的 JSON 字符串转换为 JavaScript 对象。
3. 填充 req.body：将转换后的对象填充到 req.body 属性中，后续的路由处理函数就能直接访问。
如果你的 Express 服务器需要接收和处理 JSON 格式的请求体，那么`app.use(express.json())`就必须要有。

2、app.use和app.all是匹配所有方法的请求。那app.all与app.use的区别是，app.use()是匹配路径前缀；app.all() 是精确匹配路径。如下所示：
```js
// app.use() - 匹配路径前缀
app.use('/admin', (req, res, next) => {
  console.log('Matches /admin, /admin/users, /admin/settings etc.');
  next();
});

// app.all() - 精确匹配路径
app.all('/admin', (req, res, next) => {
  console.log('Only matches exactly /admin');
  next();
});
```

3、next(): 继续执行下一个中间件，否则请求处理终止在这里，如下所示：
```js
// app.use() - 匹配路径前缀
app.use('/admin', (req, res, next) => {
  console.log('Matches /admin, /admin/users, /admin/settings etc.');
  next();
});

// app.all() - 精确匹配路径
app.all('/admin', (req, res, next) => {
  console.log('Only matches exactly /admin');
  next();
});
```
那上面例子中404的中间键处理为什么没有next()呢？因为在 Express 中，当调用 res.send(), res.json(), res.end() 等方法后，请求-响应周期就结束了，不能再调用 next()。

**关键对比分析：**
```bash
功能	           原生 Node.js	                           Express.js
路由处理	   手动解析 URL 和 method	               声明式路由 (app.get(), app.post())
查询参数	   手动解析 url.parse()	                   自动解析 (req.query)
请求体解析	   手动处理数据流 + JSON 解析	             一行中间件 (express.json())
响应处理	   手动设置 headers + res.end()	           智能方法 (res.send(), res.json())
404处理	      在每个分支手动判断	                    统一中间件处理
错误处理	   需要 try/catch 包裹	                   统一错误处理中间件
```

## 3、服务请求+响应的完整路径
当然，express自然也是支持像fetch这样，发送服务请求的功能。
# (1) fetch
```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer your_token' // 身份验证示例
  },
  body: JSON.stringify({ // 必须字符串化
    name: 'John',
    age: 30
  })
})
```
nodejs的http模块：https://www.nodeapp.cn/http.html#http_class_http_agent。总的来说，http 模块主要围绕两大核心功能展开：
1. http.createServer() - 创建 HTTP 服务器
2. http.request() - 发起 HTTP 客户端请求
其他类都是为这两大功能服务的"组件"或"工具类"。

# (2) express
```js
// 4. 创建服务请求
const clientReq = http.request('http://localhost:3000', (clientRes) => {
  // clientRes 是 IncomingMessage - 读取服务器响应
  let data = '';
  clientRes.on('data', chunk => data += chunk);
  clientRes.on('end', () => console.log('服务器响应:', data));
});

clientReq.end(); // 发送请求
```
express官网：https://www.expressjs.com.cn/guide/routing.html。

这里只是皮毛，真正学习后端开发，需要nodejs、express的全面学习。