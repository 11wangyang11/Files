## 1、模拟服务并发，一次最多3个。
这里只是使用了setTimeout模拟的并发，实际并发是针对 I/O 操作（网络、文件等），优化 I/O 操作的并行度。
```js
const req = request(3);
req(a_url).then(() => {console.log(‘111’);})
req(b_url).then(() => {console.log(‘111’);})
req(c_url).then(() => {console.log(‘111’);})
req(d_url).then(() => {console.log(‘111’);})
```
# （1）方法1
```js
class ConcurrencyController {
  constructor(max) {
    this.max = max;         // 最大并发数
    this.queue = [];        // 等待队列
    this.running = 0;       // 运行中的任务数
  }

  async execute(taskFn, resolve, reject) {
    this.running++;
    try {
      const result = await taskFn();
      resolve(result);
    } catch (err) {
      reject(err);
    } finally {
      this.running--;
      this.next();
    }
  }

  next() {
    while (this.running < this.max && this.queue.length) {
      const { taskFn, resolve, reject } = this.queue.shift();
      this.execute(taskFn, resolve, reject);
    }
  }

  add(taskFn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ taskFn, resolve, reject }); // 传递resolve和reject，是为了实现每个任务对应独立Promise的控制。
      this.next();
    });
  }
}

// 创建并发控制的请求函数
function request(maxConcurrent) {
  const controller = new ConcurrencyController(maxConcurrent);
  
  return (url) => {
    // 此处可以替换为真实的请求逻辑（如 fetch/axios）
    const task = () => new Promise(resolve => {
      const delay = Math.random() * 2000 + 1000;
      setTimeout(() => {
        console.log(`请求完成: ${url} (耗时 ${delay}ms)`);
        resolve();
      }, delay);
    });
    
    return controller.add(task);
  };
}

/******************** 使用示例 ********************/
const req = request(3); // 最大并发3

// 发起多个请求（自动排队）
req('url_A').then(() => console.log('回调 A'));
req('url_B').then(() => console.log('回调 B'));
req('url_C').then(() => console.log('回调 C'));
req('url_D').then(() => console.log('回调 D'));
req('url_E').then(() => console.log('回调 E'));

/* 输出示例：
请求完成: url_A (耗时 1234ms)
回调 A
请求完成: url_B (耗时 1356ms)
回调 B
请求完成: url_C (耗时 1423ms)
回调 C
请求完成: url_D (耗时 987ms)
回调 D
请求完成: url_E (耗时 1321ms)
回调 E
*/
```
最终结果并不是按照同步代码调用req的顺序输出的，而是异步请求时间短的早输出结果。另外，这里的return方法是传入url参数，内部模拟的fetch。如果是外部模拟fetch方法，将任务传入request也可以改造，如下：
```js
return (task) => {
    return controller.add(task);
};
```
上面每个任务加入队列的同时，也加入了对应resolve和reject方法。下面针对传入任务的方式，也提供了另一种写法，使用闭包的方法捕获resolve和reject，不需要手动加入resolve和reject。
# （2）方法2
```js
class ConcurrencyController {
  constructor(maxConcurrent = 3) {
    this.max = maxConcurrent;      // 最大并发数
    this.queue = [];               // 等待队列
    this.running = 0;              // 当前运行中的任务数
  }

  // 添加任务到队列
  add(task) {
    return new Promise((resolve, reject) => {
      // 将任务包装为可执行函数（闭包捕获resolve和reject）
      const wrappedTask = async () => {
        this.running++; // 取出任务执行时，running++
        try {
          const result = await task();
          resolve(result);
        } catch (error) {
          reject(error);
        } finally {
          this.running--; // 任务执行完，running--
          this.next(); // 触发下一个任务
        }
      };
      
      this.queue.push(wrappedTask);
      this.next(); // 尝试立即执行
    });
  }
  // 内部函数wrappedTask内引了外部Promise executor 函数作用域的resolve 和 reject，并且wrappedTask还被放入了外部的queue中，构成了闭包。

  // 执行下一个任务
  next() {
    while (this.running < this.max && this.queue.length > 0) {
      const task = this.queue.shift(); // 从队列取出任务
      task(); // 执行任务
    }
  }
}
```

```js
// 使用示例 ----------------------
// 1. 创建并发控制器（最大并发数3）
const controller = new ConcurrencyController(3);

// 2. 创建模拟任务（返回Promise的异步函数）
const createTask = (id, delay) => () => 
  new Promise(resolve => setTimeout(() => {
    console.log(`任务 ${id} 完成，耗时 ${delay}ms`);
    resolve(id);
  }, delay));

// 3. 生成10个测试任务（随机1-3秒）
const tasks = Array.from({ length: 10 }, (_, i) => 
  createTask(i, Math.random() * 2000 + 1000));

// 4. 添加所有任务到控制器
const promises = tasks.map(task => controller.add(task));

// 5. 等待所有任务完成
Promise.all(promises).then(() => {
  console.log("所有任务执行完成！");
});
```


## 2、扩展基础并发控制器，支持任务优先级（高优先级任务优先执行）
应用场景：
1. 即时通讯消息发送（重要消息优先）、关键接口优先请求。

解决思路：
1. 使用优先队列（堆结构）代替普通队列
2. 任务入队时根据优先级排序

```js
class ConcurrencyController {
    constructor(maxConcurrent) {
        this.max = maxConcurrent;
        this.queue = []; // 有优先级排序
        this.running = 0;
    }
    add(task, priority=5) {
        return new Promise((resolve, reject) => {
            const wrapperTask = async () => {
                this.running++;
                try {
                    const result = await task();
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    this.running--;
                    this.next();
                }
            };
            const position = this.queue.findIndex(item => item.priority > priority);
            this.queue.splice(position === -1 ? this.queue.length : position, 0, {wrapperTask, priority}); // 插到比他优先级低的前面
            this.next();
        });
    }
    next() {
        while(this.running < this.max && this.queue.length) {
            this.queue.shift().wrapperTask();
        } 
    }
}
```

## 3、错误重试机制
题目：实现一个支持自动重试的并发控制器，每个任务失败后最多重试 3 次。
应用场景：
1. 不稳定的网络请求、第三方服务调用

解决思路：
1. 重新包装任务函数，加入重试计数器
2. 在reject的时候，触发重试

```js
class ConcurrencyRetryController {
    constructor(maxConcurrent, maxRetries=3) {
        this.max = maxConcurrent;
        this.maxRetries = maxRetries;
        this.queue = [];
        this.running = 0;
    }
    add(task) {
        return new Promise((resolve, reject) => {
            const retryTask = async (retryCount=0) => {
                this.running++;
                try {
                    const result = await task();
                    resolve(result);
                } catch (error) {
                    if (retryCount < this.maxRetries) {
                        this.queue.push(() => retryWrapper(retryCount + 1));
                    } else {
                        reject(error);
                    }
                } finally {
                    this.running--;
                    this.next();
                }
            };
            this.queue.push(() => retryTask()); // 使用箭头函数包装，这样可以支持传retryCount参数，且不会立即执行
            this.next();
        });
    }
    next() {
        while(this.running < this.max && this.queue.length) {
            const task = this.queue.shift();
            task(); // 注意，task是包装的箭头函数
        } 
    }
}
```

## 4、任务超时控制
任务超时控制是指在执行异步任务时设置一个时间限制，如果任务在指定时间内未完成，则主动终止并抛出超时错误。这种机制用于防止因任务耗时过长导致程序阻塞，提高系统的响应性和稳定性。

应用场景：
1. 当需要执行可能耗时的异步操作（如网络请求、文件读写）时，为防止长时间等待，调用timeoutTask包装任务并设置超时时间。

实现原理：
1. timeoutTask函数：使用Promise.race将异步任务和一个超时Promise进行竞争。若任务在超时时间内完成，返回任务结果；若超时，则抛出错误。
2. 并发控制：将包装后的任务添加到并发控制器中，确保任务按设定的并发数执行，避免资源过载。

这里，我们就不用改造并发`ConcurrencyController`了，我们需要对task进行改造，如下：
```js
function timeoutTask(task, timeout) {
  return Promise.race([
    task(), // 执行原始任务
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), timeout) // 超时控制
    )]);
}
```

```js
// 使用示例 ------------------------------
const controller = new ConcurrencyController(2); // 允许同时执行2个任务

// 模拟网络请求，delay参数控制耗时
const mockFetch = (url, delay) => () => 
  new Promise((resolve) => 
    setTimeout(() => {
      console.log(`请求完成: ${url}`);
      resolve(url);
    }, delay)
  );

// 添加任务（设置不同延迟和超时时间）
controller.add(() => 
  timeoutTask(mockFetch('https://api.example.com/data1', 3000), 2000)
).catch(err => console.log(`任务1失败: ${err.message}`)); // 超时失败

controller.add(() => 
  timeoutTask(mockFetch('https://api.example.com/data2', 1000), 2000)
).then(() => console.log('任务2成功')); // 正常完成
```

**介绍Promise的几个方法**
```
方法	                   行为	                                        典型场景
Promise.all()	        等待所有 Promise 完成	                   批量处理需全部成功的任务
Promise.any()	        取第一个成功的 Promise	                       多备用源请求
Promise.allSettled()	等待所有 Promise 完成（无论成功失败）	       收集完整执行结果
Promise.race()	        取第一个完成的 Promise（无论成功失败）	      超时控制、竞速请求
```

## 5、动态调整并发数
实现原理：增加一个setMax方法，调用时更改this.max。
```js
class DynamicController {
  constructor(max) {
    this.setMax(max);
    this.queue = [];
    this.running = 0;
  }

  setMax(newMax) {
    this.max = newMax;
    this.next(); // 立即触发调整
  }

  // add 和 next 方法与基础控制器相同
}
```

## 6、






