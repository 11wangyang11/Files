## 1、模拟服务并发，一次最多3个。
这里只是使用了setTimeout模拟的并发，实际并发是针对 I/O 操作（网络、文件等），优化 I/O 操作的并行度。
```js
const req = request(3);
req(a_url).then(() => {console.log(‘111’);})
req(b_url).then(() => {console.log(‘111’);})
req(c_url).then(() => {console.log(‘111’);})
req(d_url).then(() => {console.log(‘111’);})
```
# （1）方法1
```js
class ConcurrencyController {
  constructor(max) {
    this.max = max;         // 最大并发数
    this.queue = [];        // 等待队列
    this.running = 0;       // 运行中的任务数
  }

  async execute(taskFn, resolve, reject) {
    this.running++;
    try {
      const result = await taskFn();
      resolve(result);
    } catch (err) {
      reject(err);
    } finally {
      this.running--;
      this.next();
    }
  }

  next() {
    while (this.running < this.max && this.queue.length) {
      const { taskFn, resolve, reject } = this.queue.shift();
      this.execute(taskFn, resolve, reject);
    }
  }

  add(taskFn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ taskFn, resolve, reject }); // 传递resolve和reject，是为了实现每个任务对应独立Promise的控制。
      this.next();
    });
  }
}

// 创建并发控制的请求函数
function request(maxConcurrent) {
  const controller = new ConcurrencyController(maxConcurrent);
  
  return (url) => {
    // 此处可以替换为真实的请求逻辑（如 fetch/axios）
    const task = () => new Promise(resolve => {
      const delay = Math.random() * 2000 + 1000;
      setTimeout(() => {
        console.log(`请求完成: ${url} (耗时 ${delay}ms)`);
        resolve();
      }, delay);
    });
    
    return controller.add(task);
  };
}

/******************** 使用示例 ********************/
const req = request(3); // 最大并发3

// 发起多个请求（自动排队）
req('url_A').then(() => console.log('回调 A'));
req('url_B').then(() => console.log('回调 B'));
req('url_C').then(() => console.log('回调 C'));
req('url_D').then(() => console.log('回调 D'));
req('url_E').then(() => console.log('回调 E'));

/* 输出示例：
请求完成: url_A (耗时 1234ms)
回调 A
请求完成: url_B (耗时 1356ms)
回调 B
请求完成: url_C (耗时 1423ms)
回调 C
请求完成: url_D (耗时 987ms)
回调 D
请求完成: url_E (耗时 1321ms)
回调 E
*/
```
最终结果并不是按照同步代码调用req的顺序输出的，而是异步请求时间短的早输出结果。另外，这里的return方法是传入url参数，内部模拟的fetch。如果是外部模拟fetch方法，将任务传入request也可以改造，如下：
```js
return (task) => {
    return controller.add(task);
};
```
上面每个任务加入队列的同时，也加入了对应resolve和reject方法。下面针对传入任务的方式，也提供了另一种写法，使用闭包的方法捕获resolve和reject，不需要手动加入resolve和reject。
# （2）方法2
```js
class ConcurrencyController {
  constructor(maxConcurrent = 3) {
    this.max = maxConcurrent;      // 最大并发数
    this.queue = [];               // 等待队列
    this.running = 0;              // 当前运行中的任务数
  }

  // 添加任务到队列
  add(task) {
    return new Promise((resolve, reject) => {
      // 将任务包装为可执行函数（闭包捕获resolve和reject）
      const wrappedTask = async () => {
        this.running++; // 取出任务执行时，running++
        try {
          const result = await task();
          resolve(result);
        } catch (error) {
          reject(error);
        } finally {
          this.running--; // 任务执行完，running--
          this.next(); // 触发下一个任务
        }
      };
      
      this.queue.push(wrappedTask);
      this.next(); // 尝试立即执行
    });
  }
  // 内部函数wrappedTask内引了外部Promise executor 函数作用域的resolve 和 reject，并且wrappedTask还被放入了外部的queue中，构成了闭包。

  // 执行下一个任务
  next() {
    while (this.running < this.max && this.queue.length > 0) {
      const task = this.queue.shift(); // 从队列取出任务
      task(); // 执行任务
    }
  }
}
```

```js
// 使用示例 ----------------------
// 1. 创建并发控制器（最大并发数3）
const controller = new ConcurrencyController(3);

// 2. 创建模拟任务（返回Promise的异步函数）
const createTask = (id, delay) => () => 
  new Promise(resolve => setTimeout(() => {
    console.log(`任务 ${id} 完成，耗时 ${delay}ms`);
    resolve(id);
  }, delay));

// 3. 生成10个测试任务（随机1-3秒）
const tasks = Array.from({ length: 10 }, (_, i) => 
  createTask(i, Math.random() * 2000 + 1000));

// 4. 添加所有任务到控制器
const promises = tasks.map(task => controller.add(task));

// 5. 等待所有任务完成
Promise.all(promises).then(() => {
  console.log("所有任务执行完成！");
});
```


## 2、扩展基础并发控制器，支持任务优先级（高优先级任务优先执行）：
```js
scheduler.addTask(taskFn, priority); // priority 1（高）~5（低）
```
解决思路：
1. 使用优先队列（堆结构）代替普通队列
2. 任务入队时根据优先级排序
```js
class ConcurrencyController {
    constructor(maxConcurrent) {
        this.max = maxConcurrent;
        this.queue = []; // 有优先级排序
        this.running = 0;
    }
    add(task, priority=5) {
        return new Promise((resolve, reject) => {
            const wrapperTask = async () => {
                this.running++;
                try {
                    const result = await task();
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    this.running--;
                    this.next();
                }
            };
            const position = this.queue.findIndex(item => item.priority > priority);
            this.queue.splice(position === -1 ? this.queue.length : position, 0, {wrapperTask, priority}); // 插到比他优先级低的前面
            this.next();
        });
    }
    next() {
        while(this.running < this.max && this.queue.length) {
            this.queue.shift().wrapperTask();
        } 
    }
}
```

## 3、



