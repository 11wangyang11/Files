## 一、结构
# 1、节点
```js
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}
```
# 2、构建二叉树
```js
// 示例：构建二叉树 [1, null, 2, 3]
const root = new TreeNode(1);
root.right = new TreeNode(2);
root.right.left = new TreeNode(3);
```

## 二、二叉树的遍历
二叉树的遍历主要包括**深度优先遍历（先序、中序、后序）**和**广度优先遍历（层次遍历）**。其中，深度优先遍历可以使用*递归和栈*进行遍历，递归和栈的**后进先出（LIFO）**的特性，完美契合二叉树的深度遍历特点。栈本质上就是用来存储未访问的结点。比如先序遍历，可以做到先处理左子树，暂存右子树，直到左子树*全部*执行完毕，再处理右子树。
        1
    2     3
  4  5   6  7
前序遍历：1-2-4-5-3-6-7
中序遍历：4-2-5-1-6-3-7
后序遍历：4-5-2-6-7-3-1
层次遍历：1-2-3-4-5-6-7

# 1、先序遍历（根-左-右）
```js
// 递归方法
function preOrderTraverse(root) {
    let result = [];
    function recursion(node) {
        if(!node) return;
        result.push(node.val);
        recursion(node.left);
        recursion(node.right);
    }
    recursion(root);
    return result;
}
```
```js
// 栈
function preOrderTraverse(root) {
    let stack = [root];
    let result = [];
    while(stack.length) {
        const pop = stack.pop();
        result.push(pop.val);
        if(pop.right) {
            stack.push(pop.right);
        }
        if(pop.left) {
            stack.push(pop.left);
        }
    }
    return result;
}
```

# 2、中序遍历（左-根-右）
前序遍历的栈实现会在压入右子节点前访问根节点，而中序遍历需要先压入所有左子节点，直到左到底后才访问根节点。这是两者代码差异的核心原因。
```js
// 递归
function inOrderTraverse(root) {
    let result = [];
    function traverse(root) {
        if(!root) {
            return;
        }
        if(root.left) {
            traverse(root.left);
        }
        result.push(root.val);
        if(root.right) {
            traverse(root.right);
        }
    }
    traverse(root);
    return result;
}
```

```js
// 栈
function inOrderTraverse(root) {
    let result = [];
    let stack = [];
    let cur = root;
    // 因为是从stack中取出节点后才遍历结果，所以stack有可能是空的，只要cur还有值就可以继续。光判断cur也不行，因为cur会指向null。
    while(cur || stack.length) { 
        // 内层循环：向左深入到底，将路径上的所有节点压入栈中
        while(cur) {
            stack.push(cur);
            cur = cur.left;
        }
        const node = stack.pop();
        result.push(node.val);
        cur = node.right;  // 转向右子树，进入下一轮外层循环
    }
}
```

# 3、后序遍历（左-右-根）
在后序遍历中，存在重复访问的问题，主要源于其遍历顺序（左 → 右 → 根）与栈的 “后进先出” 特性之间的矛盾。这个矛盾在递归中不存在，因为**递归隐式地利用了系统栈的上下文保存能力**，而显式栈缺乏这种自动状态管理，必须通过标记或反转前序等技巧，手动模拟递归的依赖逻辑。其实，后序遍历的栈方法可以简单一点，那就是后序遍历改为(根-右-左)的前序遍历，然后反转结果就得到了后序遍历。这一特点我们不去证明。
```js
// 递归
function postorderTraverse(root) {
    let result = [];
    function traverse(root) {
        if(root.left) {
            traverse(root.left);
        }
        if(root.right) {
            traverse(root.right);
        }
        result.push(root.val);
    }
    traverse(root);
    return result;
}
```

```js
// 栈
function postorderTraversal(root) {
    const stack = [];        // 显式栈，用于模拟递归
    const result = [];       // 存储遍历结果
    let curr = root;         // 当前遍历指针，从根节点开始
    let prev = null;         // 记录上一个访问的节点

    // 外层循环：只要存在未处理的节点或未回溯的路径，就继续遍历
    while (curr !== null || stack.length > 0) {
        // 内层循环：向左深入到底，将路径上的所有节点压入栈中
        while (curr !== null) {
            stack.push(curr);
            curr = curr.left;
        }

        // 查看栈顶节点（不弹出）
        curr = stack[stack.length - 1];

        // 判断右子树是否已处理
        if (curr.right === null || curr.right === prev) {
            result.push(curr.val); // 访问根节点
            stack.pop();           // 弹出已访问的节点
            prev = curr;          // 更新 prev 指针
            curr = null;          // 防止重复处理左子树
        } else {
            // 转向右子树
            curr = curr.right;
        }
    }
    return result;
}
```

# 4、层次遍历
队列（Queue）的 先进先出（First In First Out, FIFO），适合层次遍历。
```js
function leverOrder(root) {
    if(!root) {
        return [];
    }
    let queue = [root];
    let result = [];
    while(queue.length) {
        const length = queue.length;
        for(let i=0;i<length;i++) {
            const node = queue.shift();
            // let level = []; // 也可以每层放进一个数组中
            // level.push(node.val);
            result.push(node.val);
            if(node.left) {
                queue.push(node.left);
            }
            if(node.right){
                queue.push(node.right);
            }
        }
    }
    return result;
}
```


## 三、二叉树的类型
