<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端异步任务处理演示</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
        }
        
        .card h2 {
            color: #3498db;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        input, button {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        input:focus {
            border-color: #3498db;
            outline: none;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-top: 10px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        .btn-secondary {
            background: #2ecc71;
        }
        
        .btn-secondary:hover {
            background: #27ae60;
        }
        
        .btn-danger {
            background: #e74c3c;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .progress-container {
            margin: 20px 0;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 20px;
            background: #3498db;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .result {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            min-height: 40px;
            font-weight: 600;
        }
        
        .logs {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            font-family: monospace;
            font-size: 14px;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .status {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
        }
        
        .status-idle {
            background: #bdc3c7;
            color: #2c3e50;
        }
        
        .status-processing {
            background: #f39c12;
            color: white;
        }
        
        .status-completed {
            background: #2ecc71;
            color: white;
        }
        
        .status-error {
            background: #e74c3c;
            color: white;
        }
        
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>前端异步任务处理演示</h1>
            <p class="subtitle">避免阻塞主线程的常见场景实现</p>
        </header>
        
        <div class="grid">
            <!-- 累加计算卡片 -->
            <div class="card">
                <h2>累加计算</h2>
                <p>计算1到n的累加和，每15ms暂停一次避免阻塞主线程</p>
                
                <div class="form-group">
                    <label for="sumInput">输入 n 的值:</label>
                    <input type="number" id="sumInput" min="1" max="100000000" value="1000000">
                </div>
                
                <button id="sumBtn">开始计算</button>
                <button id="cancelSumBtn" class="btn-danger">取消计算</button>
                
                <div class="progress-container">
                    <div class="progress-bar" id="sumProgress"></div>
                </div>
                
                <div class="result" id="sumResult">
                    <span class="status status-idle">空闲</span> 等待计算...
                </div>
            </div>
            
            <!-- 大列表渲染卡片 -->
            <div class="card">
                <h2>大列表渲染</h2>
                <p>分批次渲染大型列表，保持UI响应性</p>
                
                <div class="form-group">
                    <label for="listInput">输入列表项数量:</label>
                    <input type="number" id="listInput" min="100" max="100000" value="10000">
                </div>
                
                <button id="renderBtn" class="btn-secondary">开始渲染</button>
                <button id="clearListBtn" class="btn-danger">清除列表</button>
                
                <div class="progress-container">
                    <div class="progress-bar" id="listProgress"></div>
                </div>
                
                <div class="logs" id="listLogs">
                    <div class="log-entry">等待操作...</div>
                </div>
            </div>
            
            <!-- 文件处理卡片 -->
            <div class="card">
                <h2>文件处理</h2>
                <p>模拟大文件处理，分块处理避免UI冻结</p>
                
                <div class="form-group">
                    <label for="fileSizeInput">模拟文件大小 (MB):</label>
                    <input type="number" id="fileSizeInput" min="1" max="1000" value="100">
                </div>
                
                <button id="processFileBtn" class="btn-secondary">处理文件</button>
                <button id="cancelFileBtn" class="btn-danger">取消处理</button>
                
                <div class="progress-container">
                    <div class="progress-bar" id="fileProgress"></div>
                </div>
                
                <div class="result" id="fileResult">
                    <span class="status status-idle">空闲</span> 等待文件处理...
                </div>
            </div>
            
            <!-- 动画效果卡片 -->
            <div class="card">
                <h2>动画效果</h2>
                <p>复杂动画与计算结合，保持流畅性</p>
                
                <div class="form-group">
                    <label for="particlesInput">粒子数量:</label>
                    <input type="number" id="particlesInput" min="100" max="10000" value="2000">
                </div>
                
                <button id="animateBtn" class="btn-secondary">开始动画</button>
                <button id="stopAnimationBtn" class="btn-danger">停止动画</button>
                
                <div class="progress-container">
                    <div class="progress-bar" id="animationProgress"></div>
                </div>
                
                <div class="result" id="animationResult">
                    <span class="status status-idle">空闲</span> 点击开始按钮
                </div>
            </div>
        </div>
    </div>

    <script>
        // 累加计算实现
        function createSumAsync() {
            let cancelRequested = false;
            let currentTaskId = 0;
            
            async function sumAsync(n) {
                const taskId = ++currentTaskId;
                cancelRequested = false;
                
                if (n <= 0) return 0;
                
                let sum = 0;
                let current = 1;
                const TIME_LIMIT = 15; // 每个时间片15ms
                
                // 更新UI状态
                updateSumResult(`<span class="status status-processing">处理中</span> 计算开始...`, 0);
                
                try {
                    while (current <= n) {
                        if (cancelRequested && taskId === currentTaskId) {
                            throw new Error("计算被取消");
                        }
                        
                        const startTime = performance.now();
                        
                        // 在当前时间片内尽可能多地累加
                        while (current <= n) {
                            sum += current;
                            current++;
                            
                            // 每1000次更新一次进度
                            if (current % 1000 === 0) {
                                const progress = Math.min(100, Math.floor((current / n) * 100));
                                updateSumProgress(progress);
                                
                                // 检查时间限制
                                if (performance.now() - startTime >= TIME_LIMIT) {
                                    break;
                                }
                            }
                        }
                        
                        // 让出主线程
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    
                    if (taskId === currentTaskId) {
                        updateSumResult(`<span class="status status-completed">完成</span> 计算结果: ${sum.toLocaleString()}`, 100);
                    }
                    return sum;
                } catch (error) {
                    if (taskId === currentTaskId) {
                        updateSumResult(`<span class="status status-error">已取消</span> ${error.message || "计算中断"}`, 0);
                    }
                    throw error;
                }
            }
            
            function cancel() {
                cancelRequested = true;
            }
            
            function updateSumResult(message, progress) {
                document.getElementById('sumResult').innerHTML = message;
                document.getElementById('sumProgress').style.width = `${progress}%`;
            }
            
            function updateSumProgress(progress) {
                document.getElementById('sumProgress').style.width = `${progress}%`;
            }
            
            return {
                sumAsync,
                cancel
            };
        }
        
        // 大列表渲染实现
        function createListRenderer() {
            let cancelRequested = false;
            let currentTaskId = 0;
            
            async function renderLargeList(itemCount) {
                const taskId = ++currentTaskId;
                cancelRequested = false;
                
                const logsElement = document.getElementById('listLogs');
                logsElement.innerHTML = '<div class="log-entry">开始渲染...</div>';
                
                try {
                    const chunkSize = 500; // 每次渲染的项数
                    let renderedCount = 0;
                    
                    while (renderedCount < itemCount) {
                        if (cancelRequested && taskId === currentTaskId) {
                            throw new Error("渲染被取消");
                        }
                        
                        // 模拟渲染区块
                        const chunkEnd = Math.min(renderedCount + chunkSize, itemCount);
                        
                        // 更新进度
                        const progress = Math.floor((chunkEnd / itemCount) * 100);
                        document.getElementById('listProgress').style.width = `${progress}%`;
                        
                        // 添加日志
                        const logEntry = document.createElement('div');
                        logEntry.className = 'log-entry';
                        logEntry.textContent = `渲染项: ${renderedCount + 1} - ${chunkEnd}`;
                        logsElement.appendChild(logEntry);
                        logsElement.scrollTop = logsElement.scrollHeight;
                        
                        renderedCount = chunkEnd;
                        
                        // 让出主线程
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    
                    if (taskId === currentTaskId) {
                        logsElement.innerHTML += '<div class="log-entry" style="color:#27ae60;font-weight:bold;">渲染完成!</div>';
                    }
                } catch (error) {
                    if (taskId === currentTaskId) {
                        logsElement.innerHTML += `<div class="log-entry" style="color:#e74c3c;font-weight:bold;">${error.message || "渲染中断"}</div>`;
                    }
                    throw error;
                }
            }
            
            function cancel() {
                cancelRequested = true;
            }
            
            function clearList() {
                const logsElement = document.getElementById('listLogs');
                logsElement.innerHTML = '<div class="log-entry">列表已清除</div>';
                document.getElementById('listProgress').style.width = '0%';
            }
            
            return {
                renderLargeList,
                cancel,
                clearList
            };
        }
        
        // 文件处理实现
        function createFileProcessor() {
            let cancelRequested = false;
            let currentTaskId = 0;
            
            async function processFile(fileSizeMB) {
                const taskId = ++currentTaskId;
                cancelRequested = false;
                
                // 模拟文件大小 (MB 转换为字节)
                const fileSizeBytes = fileSizeMB * 1024 * 1024;
                const blockSize = 1024 * 256; // 256KB 块大小
                let processedBytes = 0;
                
                // 更新UI状态
                updateFileResult(`<span class="status status-processing">处理中</span> 开始处理 ${fileSizeMB}MB 文件...`, 0);
                
                try {
                    while (processedBytes < fileSizeBytes) {
                        if (cancelRequested && taskId === currentTaskId) {
                            throw new Error("文件处理被取消");
                        }
                        
                        // 处理一个块
                        const processSize = Math.min(blockSize, fileSizeBytes - processedBytes);
                        
                        // 模拟处理时间 (每MB约5ms)
                        await new Promise(resolve => setTimeout(resolve, (processSize / (1024 * 1024)) * 5));
                        
                        processedBytes += processSize;
                        
                        // 更新进度
                        const progress = Math.floor((processedBytes / fileSizeBytes) * 100);
                        updateFileProgress(progress);
                    }
                    
                    if (taskId === currentTaskId) {
                        updateFileResult(`<span class="status status-completed">完成</span> 文件处理成功!`, 100);
                    }
                } catch (error) {
                    if (taskId === currentTaskId) {
                        updateFileResult(`<span class="status status-error">已取消</span> ${error.message || "文件处理中断"}`, Math.floor((processedBytes / fileSizeBytes) * 100));
                    }
                    throw error;
                }
            }
            
            function cancel() {
                cancelRequested = true;
            }
            
            function updateFileResult(message, progress) {
                document.getElementById('fileResult').innerHTML = message;
                document.getElementById('fileProgress').style.width = `${progress}%`;
            }
            
            function updateFileProgress(progress) {
                document.getElementById('fileProgress').style.width = `${progress}%`;
            }
            
            return {
                processFile,
                cancel
            };
        }
        
        // 动画效果实现
        function createAnimationHandler() {
            let animationRunning = false;
            let animationFrame;
            
            function startAnimation(particleCount) {
                if (animationRunning) return;
                
                animationRunning = true;
                updateAnimationResult(`<span class="status status-processing">运行中</span> 粒子动画进行中...`);
                
                let particles = Array.from({ length: particleCount }, () => ({
                    x: Math.random() * 100,
                    y: Math.random() * 100,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2
                }));
                
                let frameCount = 0;
                const startTime = performance.now();
                
                function animate() {
                    if (!animationRunning) return;
                    
                    // 更新粒子位置
                    for (let i = 0; i < particles.length; i++) {
                        particles[i].x += particles[i].vx * 0.1;
                        particles[i].y += particles[i].vy * 0.1;
                        
                        // 边界检查
                        if (particles[i].x < 0 || particles[i].x > 100) {
                            particles[i].vx *= -1;
                        }
                        if (particles[i].y < 0 || particles[i].y > 100) {
                            particles[i].vy *= -1;
                        }
                    }
                    
                    frameCount++;
                    
                    // 每60帧更新一次进度
                    if (frameCount % 60 === 0) {
                        const elapsed = performance.now() - startTime;
                        const fps = Math.round((frameCount * 1000) / elapsed);
                        const progress = frameCount % 100;
                        
                        updateAnimationResult(`<span class="status status-processing">运行中</span> 帧率: ${fps} FPS | 粒子数: ${particles.length}`);
                        document.getElementById('animationProgress').style.width = `${progress}%`;
                    }
                    
                    animationFrame = requestAnimationFrame(animate);
                }
                
                animate();
            }
            
            function stopAnimation() {
                if (!animationRunning) return;
                
                animationRunning = false;
                cancelAnimationFrame(animationFrame);
                updateAnimationResult(`<span class="status status-completed">已停止</span> 动画已终止`);
            }
            
            function updateAnimationResult(message) {
                document.getElementById('animationResult').innerHTML = message;
            }
            
            return {
                startAnimation,
                stopAnimation
            };
        }
        
        // 初始化功能模块
        const sumCalculator = createSumAsync();
        const listRenderer = createListRenderer();
        const fileProcessor = createFileProcessor();
        const animationHandler = createAnimationHandler();
        
        // 事件监听器
        document.getElementById('sumBtn').addEventListener('click', () => {
            const n = parseInt(document.getElementById('sumInput').value);
            if (n > 0) {
                sumCalculator.sumAsync(n);
            }
        });
        
        document.getElementById('cancelSumBtn').addEventListener('click', () => {
            sumCalculator.cancel();
        });
        
        document.getElementById('renderBtn').addEventListener('click', () => {
            const itemCount = parseInt(document.getElementById('listInput').value);
            if (itemCount > 0) {
                listRenderer.renderLargeList(itemCount);
            }
        });
        
        document.getElementById('clearListBtn').addEventListener('click', () => {
            listRenderer.clearList();
        });
        
        document.getElementById('processFileBtn').addEventListener('click', () => {
            const fileSizeMB = parseInt(document.getElementById('fileSizeInput').value);
            if (fileSizeMB > 0) {
                fileProcessor.processFile(fileSizeMB);
            }
        });
        
        document.getElementById('cancelFileBtn').addEventListener('click', () => {
            fileProcessor.cancel();
        });
        
        document.getElementById('animateBtn').addEventListener('click', () => {
            const particleCount = parseInt(document.getElementById('particlesInput').value);
            if (particleCount > 0) {
                animationHandler.startAnimation(particleCount);
            }
        });
        
        document.getElementById('stopAnimationBtn').addEventListener('click', () => {
            animationHandler.stopAnimation();
        });
    </script>
</body>
</html>